// See https://aka.ms/new-console-template for more information
using pdflexer.ArlingtonGen;
using PdfLexer;

Directory.CreateDirectory("C:\\source\\github\\pdflexer\\src\\pdflexer.Validation\\APM");

var files = Directory.GetFiles($"C:\\source\\github\\arlington-pdf-model\\tsv\\latest", "*.tsv");
// var files = new List<string> { $"C:\\source\\github\\arlington-pdf-model\\tsv\\latest\\" + "3DActivation.tsv" };

var children = new Dictionary<string, List<GenBase>>();

foreach (var file in files)
{
    var type = Path.GetFileNameWithoutExtension(file);
    // if (type.StartsWith("_")) { continue; }
    try
    {
        var lines = File.ReadLines(file);
        var rows = lines.Select(x => x.Split('\t')).Select(x => new Row(x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7], x[8], x[9], x[10], x.Length > 11 ? x[11] : "")).Skip(1).ToList();
        using var fs = File.Create($"C:\\source\\github\\pdflexer\\src\\pdflexer.Validation\\APM\\{type}.cs");
        using var sw = new StreamWriter(fs);
        sw.WriteLine("// AUTOGENERATED DO NOT MODIFY");
        sw.WriteLine("");
        sw.WriteLine("using PdfLexer;");
        sw.WriteLine("using static PdfLexer.Validation.MathUtil;");
        sw.WriteLine("");
        sw.WriteLine("namespace PdfLexer.Validation;");
        sw.WriteLine("");

        var c = new List<GenBase>();
        if ((rows[0].Key.StartsWith("0") && !rows[0].Key.Contains(".")) || (type.Contains("Array")))
        {
            GenBase.Arrays.Add(type);
            var po = new ArrayMain(type);
            sw.WriteLine(po.CreateClass(rows).ReplaceLineEndings());
            
            foreach (var row in rows)
            {
                var ac = new ArrayChild(po, row, rows);
                c.Add(ac);
            }

        } else
        {
            var po = new DictMain(type);
            sw.WriteLine(po.CreateClass(rows).ReplaceLineEndings());
            foreach (var row in rows)
            {
                if (row.Key.Contains(":")) { continue; }
                var dc = new DictChild(po, rows, row);
                c.Add(dc);
            }
        }
        children[type] = c;
    } catch (Exception ex)
    {
        Console.WriteLine(type + "- " + ex.Message);
    }
}

foreach (var kvp in children)
{
    using var fs = File.Open($"C:\\source\\github\\pdflexer\\src\\pdflexer.Validation\\APM\\{kvp.Key}.cs", FileMode.Append);
    using var sw = new StreamWriter(fs);
    foreach (var c in kvp.Value)
    {
        sw.WriteLine(c.CreateClass().ReplaceLineEndings());
    }
}

using var fs2 = File.Create($"C:\\source\\github\\pdflexer\\src\\pdflexer.Validation\\MathUtils.cs");
using var sw2 = new StreamWriter(fs2);

sw2.WriteLine("""
    // AUTOGENERATED DO NOT MODIFY

    namespace PdfLexer.Validation;

    internal static partial class MathUtil
    {
    """);

var ops = new Dictionary<string, (string, string)>
{
    ["eq"] = ("==", "bool"),
    ["gt"] = (">", "bool"),
    ["lt"] = ("<", "bool"),
    ["gte"] = (">=", "bool"),
    ["lte"] = ("<=", "bool"),
    ["mult"] = ("*", "decimal"),
};
var txt = "";
foreach (var op in ops)
{
    var t = op.Key;
    var o = op.Value.Item1;
    var rt = op.Value.Item2;
    var dv = rt == "bool" ? "false" : "0m";

    var mc = "";
    if (t == "eq" || t == "ne")
    {
        mc += $$"""
    if (obj is PdfName nm1 && val is PdfName nm2) {
        return nm1.Value {{o}} nm2.Value;
    }
""";
    }

        txt += $$"""
public static {{rt}} {{t}}(IPdfObject? obj, int val)
{
    if (obj == null) { return {{dv}}; }
    var n = obj as PdfIntNumber;
    if (n == null) { return {{dv}}; }
    return {{t}}(n, val);
}
// public static {{rt}} {{t}}(PdfNumber obj, int val) 
// {
//     if (obj.NumberType == PdfNumberType.Integer) 
//     {
//         return {{t}}((PdfIntNumber)obj, val);
//     }
//     return {{t}}(obj, (decimal)val);
// }
public static {{rt}} {{t}}(PdfIntNumber obj, int val) 
{
    return (int)obj {{o}} val;
}
public static {{rt}} {{t}}(IPdfObject? obj, IPdfObject? val)
{
    if (obj == null || val == null) { return {{dv}}; } // custom for arlington eval to fail
    if (obj.Type != val.Type) { return {{dv}}; }
{{mc}}
    var n = obj as PdfNumber;
    if (n == null) { return {{dv}}; }
    var n2 = val as PdfNumber;
    if (n2 == null) { return {{dv}}; }
    return n {{o}} n2;
}

public static {{rt}} {{t}}(IPdfObject? obj, int? val)
{
    if (val == null) return {{dv}};
    return {{t}}(obj, val.Value);
}
public static {{rt}} {{t}}(int val, IPdfObject? obj) => {{t}}(obj, val);
public static {{rt}} {{t}}(int val, int val2) => val {{o}} val2;
public static {{rt}} {{t}}(int? val, int val2)
{
    if (val == null) { return {{dv}}; }
    return val.Value {{o}} val2;
}
public static {{rt}} {{t}}(IPdfObject? obj, decimal val)
{
    if (obj == null) { return {{dv}}; }
    var n = obj as PdfNumber;
    if (n == null) { return {{dv}}; }
    return  (decimal)n {{o}} val;
}
public static {{rt}} {{t}}(IPdfObject? obj, decimal? val)
{
    if (val == null) return {{dv}};
    return {{t}}(obj, val.Value);
}
public static {{rt}} {{t}}(decimal val, IPdfObject? obj) => {{t}}(obj, val);
public static {{rt}} {{t}}(decimal val, decimal val2) => val {{o}} val2;
public static {{rt}} {{t}}(decimal? val, decimal val2)
{
    if (val == null) { return {{dv}}; }
    return val.Value {{o}} val2;
}

""";

    if (t == "eq" || t == "ne")
    {
        txt += $$"""
public static {{rt}} {{t}}(IPdfObject? obj, string? val)
{
    if (obj == null || val == null) { return false; }
    var n = obj as PdfString;
    if (n == null) { return false; }
    return n.Value {{o}} val;
}

""";
    }
}

sw2.WriteLine(GenBase.Ident(4, txt));
sw2.WriteLine("}");

{
    // hack... TODO fix actual issue
    var f = "C:\\source\\github\\pdflexer\\src\\pdflexer.Validation\\APM\\Solidities.cs";
    var contents = File.ReadAllText(f);
    contents = contents.Replace("var val = ctx.GetOptional<PdfNumber, APM_Solidities_CatchAll>", "IPdfObject? val = ctx.GetOptional<PdfNumber, APM_Solidities_CatchAll>");
    File.WriteAllText(f, contents);

    // 1+m(LastChar-FirstChar)
    //1 + ((LastChar?.GetAs<PdfIntNumber>()?.Value ?? 0) - (FirstChar?.GetAs<PdfIntNumber>()?.Value ?? 0))
}

{
    // hack... TODO fix actual issue
    foreach (var c in new List<string> { "FontType1", "FontType3" })
    {
        var f = $"C:\\source\\github\\pdflexer\\src\\pdflexer.Validation\\APM\\{c}.cs";
        var contents = File.ReadAllText(f);
        contents = contents.Replace("1+m(LastChar-FirstChar)", "1 + ((LastChar?.GetAs<PdfIntNumber>()?.Value ?? 0) - (FirstChar?.GetAs<PdfIntNumber>()?.Value ?? 0))");
        File.WriteAllText(f, contents);
    }
}