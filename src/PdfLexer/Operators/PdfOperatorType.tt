<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<# var operators = new List<(string, string, string, List<(string, string)>, bool)> {
    ("b", null, "Close, fill, and stroke path using nonzero winding number rule", null, false), // no ops
    ("B", null, "Fill and stroke path using nonzero winding number rule", null, false), // no ops
    ("b*", "b_Star", "Close, fill, and stroke path using even-odd rule", null, false), // no ops
    ("B*", "B_Star", "Fill and stroke path using even-odd rule", null, false), // no ops
    ("BDC", null, "Begin marked-content sequence with property list", new List<(string, string)>{ ("PdfName", "tag"), ("PdfObject", "props") }, true),
    ("BI", null, "Begin inline image object", null, false), // no ops
    ("BMC", null, "Begin marked-content sequence", new List<(string, string)>{ ("PdfName", "tag") }, false),
    ("BT", null, "Begin text object", null, false), // no ops
    ("BX", null, "Begin compatibility section", null, false), // no ops
    ("c", null, "Append curved segment to path (three control points)", new List<(string, string)>{ ("decimal", "x1"), ("decimal", "y1"), ("decimal", "x2"), ("decimal", "y2"), ("decimal", "x3"), ("decimal", "y3")}, false),
    ("cm", null, "Concatenate matrix to current transformation matrix", new List<(string, string)>{ ("decimal", "a"), ("decimal", "b"), ("decimal", "c"), ("decimal", "d"), ("decimal", "e"), ("decimal", "f")}, false),
    ("CS", null, "Set color space for stroking operations", new List<(string, string)>{ ("PdfName", "name") }, false),
    ("cs", null, "Set color space for nonstroking operations", new List<(string, string)>{ ("PdfName", "name") }, false),
    ("d", null, "Set line dash pattern", null, false),
    ("d0", null, "Set glyph width in Type 3 font", null, false),
    ("d1", null, "Set glyph width and bounding box in Type 3 font", null, false),
    ("Do", null, "Invoke named XObject", null, false),
    ("DP", null, "Define marked-content point with property list", new List<(string, string)>{ ("PdfName", "tag"), ("PdfObject", "props") }, true),
    ("EI", null, "End inline image object", null, false), // no ops
    ("EMC", null, "End marked-content sequence", null, false), // no ops
    ("ET", null, "End text object", null, false), // no ops
    ("EX", null, "End compatibility section", null, false), // no ops
    ("f", null, "Fill path using nonzero winding number rule", null, false), // no ops
    ("F", null, "Fill path using nonzero winding number rule (obsolete)", null, false), // no ops
    ("f*", "f_Star", "Fill path using even-odd rule", null, false), // no ops
    ("G", null, "Set gray level for stroking operations", null, false),
    ("g", null, "Set gray level for nonstroking operations", null, false),
    ("gs", null, "Set parameters from graphics state parameter dictionary", null, false),
    ("h", null, "Close subpath", null, false), // no ops
    ("I", null, "Set flatness tolerance", null, false),
    ("ID", null, "Begin inline image data", null, false), // no ops
    ("j", null, "Set line join style", null, false),
    ("J", null, "Set line capstyle", null, false),
    ("K", null, "Set CMYK color for stroking operations", null, false),
    ("k", null, "Set CMYK color for nonstroking operations", null, false),
    ("l", null, "Append straight line segment to path", new List<(string, string)>{ ("decimal", "x"), ("decimal", "y")}, false),
    ("m", null, "Begin new subpath", new List<(string, string)>{ ("decimal", "x"), ("decimal", "y")}, false),
    ("M", null, "Set miter limit", null, false),
    ("MP", null, "Define marked-content point", new List<(string, string)>{ ("PdfName", "tag") }, false),
    ("n", null, "End path without filling or stroking", null, false), // no ops
    ("q", null, "Save graphics state", null, false),
    ("Q", null, "Restore graphics state", null, false),
    ("re", null, "Append rectangle to path", new List<(string, string)>{ ("decimal", "x"), ("decimal", "y"), ("decimal", "width"), ("decimal", "height") }, false),
    ("RG", null, "Set RGB color for stroking operations", null, false),
    ("rg", null, "Set RGB color for nonstroking operations", null, false),
    ("rl", null, "Set color rendering intent", null, false),
    ("s", null, "Close and stroke path", null, false), // no ops
    ("S", null, "Stroke path", null, false), // no ops
    ("SC", null, "Set color for stroking operations", new List<(string, string)>{ ("List<decimal>", "colorInfo") }, true),
    ("sc", null, "Set color for nonstroking operations", null, false),
    ("SCN", null, "Set color for stroking operations (ICCBased and special color spaces)", null, false),
    ("scn", null, "Set color for nonstroking operations (ICCBased and special color spaces)", null, false),
    ("sh", null, "Paint area defined by shading pattern", null, false),
    ("T*", "T_Star", "Move to start of next text line", null, false), // no ops
    ("Tc", null, "Set character spacing", null, false),
    ("Td", null, "Move text position", new List<(string, string)> { ("decimal", "tx"), ("decimal", "ty") }, false),
    ("TD", null, "Move text position and set leading", new List<(string, string)> { ("decimal", "tx"), ("decimal", "ty") }, false),
    ("Tf", null, "Set text font and size", null, false),
    ("Tj", null, "Show text", new List<(string, string)> { ("PdfString", "text") }, false),
    ("TJ", null, "Show text, allowing individual glyph positioning", null, false),
    ("TL", null, "Set text leading", null, false),
    ("Tm", null, "Set text matrix and text line matrix", new List<(string, string)>{ ("decimal", "a"), ("decimal", "b"), ("decimal", "c"), ("decimal", "d"), ("decimal", "e"), ("decimal", "f")}, false),
    ("Tr", null, "Set text rendering mode", null, false),
    ("Ts", null, "Set text rise", null, false),
    ("Tw", null, "Set word spacing", null, false),
    ("Tz", null, "Set horizontal text scaling", null, false),
    ("v", null, "Append curved segment to path (initial point replicated)", new List<(string, string)>{ ("decimal", "x2"), ("decimal", "y2"), ("decimal", "x3"), ("decimal", "y3")}, false),
    ("w", null, "Set line width", null, false),
    ("W", null, "Set clipping path using nonzero winding number rule", null, false),
    ("W*", "W_Star", "Set clipping path using even-odd rule", null, false),
    ("y", null, "Append curved segment to path (final point replicated)", new List<(string, string)>{ ("decimal", "x1"), ("decimal", "y1"), ("decimal", "x3"), ("decimal", "y3")}, false),
    ("'", "singlequote", "Move to next line and show text", new List<(string, string)> { ("PdfString", "text") }, false),
    ("\"", "doublequote", "Set word and character spacing, move to next line, and show text", null, false),

}; #>
using PdfLexer.Lexing;
using PdfLexer.Parsers;
using System;
using System.Collections.Generic;

/// <summary>
/// Auto-generated, do not modify.
/// </summary>

namespace PdfLexer.Operators
{
    public enum PdfOperatorType
    {
        Unknown,
        // End of content
        EOC,
<#
foreach (var op in operators) 
{
    var bytes = Encoding.ASCII.GetBytes(op.Item1);
    int key = 0;
    for (int i = 0; i < bytes.Length; i++)
    {
        key = key | (bytes[i] << 8 * i);
    } #>
        // <#= op.Item3 #>
        <#= op.Item2 == null ? op.Item1 : op.Item2 #> = <#= key #>,
<#
}
#>
    }

    public static class ParseOpMapping
    {
        public static Dictionary<int, PdfOperator.ParseOp> Parsers = new Dictionary<int, PdfOperator.ParseOp> {
<#
foreach (var op in operators) 
{
    var name = op.Item2 == null ? op.Item1 : op.Item2;
    var bytes = Encoding.ASCII.GetBytes(op.Item1);
    int key = 0;
    for (int i = 0; i < bytes.Length; i++)
    {
        key = key | (bytes[i] << 8 * i);
    }
#>
            [<#=key#>] = <# if (op.Item5) { #> PdfOperator.Parse<#= name #>, <# } else { #> <#= name #>_Op.Parse, <# } #>

<#
}
#>
        };
    }

<#
foreach (var op in operators) 
{
    var name = op.Item2 == null ? op.Item1 : op.Item2;
#>
    public partial class <#= name #>_Op : IPdfOperation
    {
        public PdfOperatorType Type => PdfOperatorType.<#= name #>;
<# if (op.Item4 == null) { #>
        public static <#= name #>_Op Value = new <#= name #>_Op();
        public <#= name #>_Op()
        {

        }
<# if (!op.Item5) { #>
        public static <#= name #>_Op Parse(ParsingContext ctx, ReadOnlySpan<byte> data, List<OperandInfo> operands) 
            => Value;
<# } #>
<# } else { #>
<#     foreach (var prop in op.Item4) { #>
        public <#= prop.Item1 #> <#= prop.Item2 #> { get; set; }
<#     } #>
        public <#= name #>_Op(<#= string.Join(", ", op.Item4.Select(i=> $"{i.Item1} {i.Item2}")) #>)
        {
<#     
       foreach (var prop in op.Item4) { 
#>
            this.<#= prop.Item2 #> = <#= prop.Item2 #>;
<#     } #>
        }
<# if (!op.Item5) { #>
        public static <#= name #>_Op Parse(ParsingContext ctx, ReadOnlySpan<byte> data, List<OperandInfo> operands) 
        {
<#     var i = 0;
       var a = "";

       foreach (var prop in op.Item4) { 
            var parser = "throw new NotImplementedException()";
            switch (prop.Item1) {
                case "decimal":
                    parser = $"PdfOperator.ParseDecimal(ctx, data, operands[{i}])";
                    break;
                default:
                    parser = $"PdfOperator.Parse{prop.Item1}(ctx, data, operands[{i}])";
                    break;
            }
            a += $"a{i}, ";
#>
            var a<#= i #> = <#= parser #>;
<#         i++; #>
<#     }
       a = a.Trim().TrimEnd(',');
#>
    
            return new <#= name #>_Op(<#= a #>);
        }
<# } #>
<# } #>
    }
<#
}

#>
}