// AUTOGENERATED DO NOT MODIFY

using PdfLexer;
using static PdfLexer.Validation.MathUtil;

namespace PdfLexer.Validation;

using System.Linq;

internal partial class APM_Navigator : APM_Navigator_Base
{
}

internal partial class APM_Navigator_Base : ISpecification<PdfDictionary>
{
    public static bool RuleGroup() { return true; }
    public static string Name { get; } = "Navigator";
    public static bool AppliesTo(decimal version, List<string> extensions) => true; // managed by links
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        ctx.Run<APM_Navigator_Type, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_Navigator_Layout, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_Navigator_SWF, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_Navigator_Name, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_Navigator_Desc, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_Navigator_Category, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_Navigator_ID, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_Navigator_Version, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_Navigator_APIVersion, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_Navigator_LoadType, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_Navigator_Icon, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_Navigator_Locale, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_Navigator_Strings, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_Navigator_InitialFields, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_Navigator_Resources, PdfDictionary>(stack, obj, parent);
        switch (ctx.Version) {
            case 2.0m:
                foreach (var extra in obj.Keys.Where(x=> !AllowedFields_20.Contains(x)))
                {
                    ctx.Fail<APM_Navigator>($"Unknown field {extra} for version 2.0");
                }
                break;
            default:
                break;
        }
    }

    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) 
    {
        var c = ctx.Clone();
        c.Run<APM_Navigator_Type, PdfDictionary>(new CallStack(), obj, null);
        if (c.Errors.Any())
        {
            return false;
        }
        return true;
    }

    public static List<string> AllowedFields_20 { get; } = new List<string> 
    {
        "Type", "Layout"
    };
    


}

/// <summary>
/// Navigator_Type Table 160
/// </summary>
internal partial class APM_Navigator_Type : APM_Navigator_Type_Base
{
}


internal partial class APM_Navigator_Type_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "Navigator_Type";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 2.0m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfName, APM_Navigator_Type>(obj, "Type", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        {
        
        
        if (!(val == "Navigator")) 
        {
            ctx.Fail<APM_Navigator_Type>($"Invalid value {val}, allowed are: [Navigator]");
        }
        }
        // no linked objects
        
    }


}

/// <summary>
/// Navigator_Layout 
/// </summary>
internal partial class APM_Navigator_Layout : APM_Navigator_Layout_Base
{
}


internal partial class APM_Navigator_Layout_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "Navigator_Layout";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 2.0m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var (utval, wasIR) = ctx.GetOptional<APM_Navigator_Layout>(obj, "Layout", IndirectRequirement.Either);
        if (utval == null) { ctx.Fail<APM_Navigator_Layout>("Layout is required"); return; }
        switch (utval.Type) 
        {
            case PdfObjectType.ArrayObj:
                {
                    var val =  (PdfArray)utval;
                    // no indirect obj reqs
                    // no special cases
                    // no value restrictions
                    ctx.Run<APM_ArrayOfNavigatorLayoutNames, PdfArray>(stack, val, obj);
                    return;
                }
            case PdfObjectType.NameObj:
                {
                    var val =  (PdfName)utval;
                    // no indirect obj reqs
                    // no special cases
                    {
                    
                    
                    if (!(val == "D" || val == "T" || val == "H" || val == "FilmStrip" || val == "FreeForm" || val == "Linear" || val == "Tree" || val == "*")) 
                    {
                        ctx.Fail<APM_Navigator_Layout>($"Invalid value {val}, allowed are: [D,T,H,FilmStrip,FreeForm,Linear,Tree,*]");
                    }
                    }
                    // no linked objects
                    return;
                }
            
            default:
                ctx.Fail<APM_Navigator_Layout>("Layout is required to one of 'array;name', was " + utval.Type);
                return;
        }
    }


}

/// <summary>
/// Navigator_SWF Adobe Extension Level 3 only
/// </summary>
internal partial class APM_Navigator_SWF : APM_Navigator_SWF_Base
{
}


internal partial class APM_Navigator_SWF_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "Navigator_SWF";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return false; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetRequired<PdfString, APM_Navigator_SWF>(obj, "SWF", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// Navigator_Name Adobe Extension Level 3 only
/// </summary>
internal partial class APM_Navigator_Name : APM_Navigator_Name_Base
{
}


internal partial class APM_Navigator_Name_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "Navigator_Name";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return false; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfString, APM_Navigator_Name>(obj, "Name", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// Navigator_Desc Adobe Extension Level 3 only
/// </summary>
internal partial class APM_Navigator_Desc : APM_Navigator_Desc_Base
{
}


internal partial class APM_Navigator_Desc_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "Navigator_Desc";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return false; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfString, APM_Navigator_Desc>(obj, "Desc", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// Navigator_Category Adobe Extension Level 3 only
/// </summary>
internal partial class APM_Navigator_Category : APM_Navigator_Category_Base
{
}


internal partial class APM_Navigator_Category_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "Navigator_Category";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return false; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfString, APM_Navigator_Category>(obj, "Category", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// Navigator_ID Adobe Extension Level 3 only
/// </summary>
internal partial class APM_Navigator_ID : APM_Navigator_ID_Base
{
}


internal partial class APM_Navigator_ID_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "Navigator_ID";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return false; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetRequired<PdfString, APM_Navigator_ID>(obj, "ID", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// Navigator_Version Adobe Extension Level 3 only
/// </summary>
internal partial class APM_Navigator_Version : APM_Navigator_Version_Base
{
}


internal partial class APM_Navigator_Version_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "Navigator_Version";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return false; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfString, APM_Navigator_Version>(obj, "Version", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// Navigator_APIVersion Adobe Extension Level 3 only
/// </summary>
internal partial class APM_Navigator_APIVersion : APM_Navigator_APIVersion_Base
{
}


internal partial class APM_Navigator_APIVersion_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "Navigator_APIVersion";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return false; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetRequired<PdfString, APM_Navigator_APIVersion>(obj, "APIVersion", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// Navigator_LoadType Adobe Extension Level 3 only
/// </summary>
internal partial class APM_Navigator_LoadType : APM_Navigator_LoadType_Base
{
}


internal partial class APM_Navigator_LoadType_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "Navigator_LoadType";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return false; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfName, APM_Navigator_LoadType>(obj, "LoadType", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        {
        
        
        if (!(val == "Module" || val == "Default")) 
        {
            ctx.Fail<APM_Navigator_LoadType>($"Invalid value {val}, allowed are: [Module,Default]");
        }
        }
        // no linked objects
        
    }


}

/// <summary>
/// Navigator_Icon Adobe Extension Level 3 only
/// </summary>
internal partial class APM_Navigator_Icon : APM_Navigator_Icon_Base
{
}


internal partial class APM_Navigator_Icon_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "Navigator_Icon";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return false; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfString, APM_Navigator_Icon>(obj, "Icon", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// Navigator_Locale Adobe Extension Level 3 only
/// </summary>
internal partial class APM_Navigator_Locale : APM_Navigator_Locale_Base
{
}


internal partial class APM_Navigator_Locale_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "Navigator_Locale";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return false; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfString, APM_Navigator_Locale>(obj, "Locale", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// Navigator_Strings Adobe Extension Level 3 only
/// </summary>
internal partial class APM_Navigator_Strings : APM_Navigator_Strings_Base
{
}


internal partial class APM_Navigator_Strings_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "Navigator_Strings";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return false; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfDictionary, APM_Navigator_Strings>(obj, "Strings", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// Navigator_InitialFields Adobe Extension Level 3 only
/// </summary>
internal partial class APM_Navigator_InitialFields : APM_Navigator_InitialFields_Base
{
}


internal partial class APM_Navigator_InitialFields_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "Navigator_InitialFields";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return false; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfDictionary, APM_Navigator_InitialFields>(obj, "InitialFields", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        ctx.Run<APM_CollectionSchema, PdfDictionary>(stack, val, obj);
        
    }


}

/// <summary>
/// Navigator_Resources Adobe Extension Level 3 only
/// </summary>
internal partial class APM_Navigator_Resources : APM_Navigator_Resources_Base
{
}


internal partial class APM_Navigator_Resources_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "Navigator_Resources";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return false; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetRequired<PdfDictionary, APM_Navigator_Resources>(obj, "Resources", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        // TODO trees
        
    }


}

