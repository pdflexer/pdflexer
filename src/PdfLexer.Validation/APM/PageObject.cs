// AUTOGENERATED DO NOT MODIFY

using PdfLexer;
using static PdfLexer.Validation.MathUtil;

namespace PdfLexer.Validation;

using System.Linq;

internal partial class APM_PageObject : APM_PageObject_Base
{
}

internal partial class APM_PageObject_Base : ISpecification<PdfDictionary>
{
    public static bool RuleGroup() { return true; }
    public static string Name { get; } = "PageObject";
    public static bool AppliesTo(decimal version, List<string> extensions) => true; // managed by links
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        ctx.Run<APM_PageObject_Type, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_PageObject_Parent, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_PageObject_LastModified, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_PageObject_Resources, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_PageObject_MediaBox, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_PageObject_CropBox, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_PageObject_BleedBox, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_PageObject_TrimBox, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_PageObject_ArtBox, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_PageObject_BoxColorInfo, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_PageObject_Contents, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_PageObject_Rotate, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_PageObject_Group, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_PageObject_Thumb, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_PageObject_B, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_PageObject_Dur, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_PageObject_Trans, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_PageObject_Annots, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_PageObject_AA, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_PageObject_Metadata, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_PageObject_PieceInfo, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_PageObject_StructParents, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_PageObject_ID, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_PageObject_PZ, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_PageObject_SeparationInfo, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_PageObject_Tabs, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_PageObject_TemplateInstantiated, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_PageObject_PresSteps, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_PageObject_UserUnit, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_PageObject_VP, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_PageObject_AF, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_PageObject_OutputIntents, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_PageObject_DPart, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_PageObject_Hid, PdfDictionary>(stack, obj, parent);
        switch (ctx.Version) {
            case 1.0m:
                foreach (var extra in obj.Keys.Where(x=> !AllowedFields_10.Contains(x)))
                {
                    ctx.Fail<APM_PageObject>($"Unknown field {extra} for version 1.0");
                }
                break;
            case 1.1m:
                foreach (var extra in obj.Keys.Where(x=> !AllowedFields_11.Contains(x)))
                {
                    ctx.Fail<APM_PageObject>($"Unknown field {extra} for version 1.1");
                }
                break;
            case 1.2m:
                foreach (var extra in obj.Keys.Where(x=> !AllowedFields_12.Contains(x)))
                {
                    ctx.Fail<APM_PageObject>($"Unknown field {extra} for version 1.2");
                }
                break;
            case 1.3m:
                foreach (var extra in obj.Keys.Where(x=> !AllowedFields_13.Contains(x)))
                {
                    ctx.Fail<APM_PageObject>($"Unknown field {extra} for version 1.3");
                }
                break;
            case 1.4m:
                foreach (var extra in obj.Keys.Where(x=> !AllowedFields_14.Contains(x)))
                {
                    ctx.Fail<APM_PageObject>($"Unknown field {extra} for version 1.4");
                }
                break;
            case 1.5m:
                foreach (var extra in obj.Keys.Where(x=> !AllowedFields_15.Contains(x)))
                {
                    ctx.Fail<APM_PageObject>($"Unknown field {extra} for version 1.5");
                }
                break;
            case 1.6m:
                foreach (var extra in obj.Keys.Where(x=> !AllowedFields_16.Contains(x)))
                {
                    ctx.Fail<APM_PageObject>($"Unknown field {extra} for version 1.6");
                }
                break;
            case 1.7m:
                foreach (var extra in obj.Keys.Where(x=> !AllowedFields_17.Contains(x)))
                {
                    ctx.Fail<APM_PageObject>($"Unknown field {extra} for version 1.7");
                }
                break;
            case 1.8m:
                foreach (var extra in obj.Keys.Where(x=> !AllowedFields_18.Contains(x)))
                {
                    ctx.Fail<APM_PageObject>($"Unknown field {extra} for version 1.8");
                }
                break;
            case 1.9m:
                foreach (var extra in obj.Keys.Where(x=> !AllowedFields_19.Contains(x)))
                {
                    ctx.Fail<APM_PageObject>($"Unknown field {extra} for version 1.9");
                }
                break;
            case 2.0m:
                foreach (var extra in obj.Keys.Where(x=> !AllowedFields_20.Contains(x)))
                {
                    ctx.Fail<APM_PageObject>($"Unknown field {extra} for version 2.0");
                }
                break;
            default:
                break;
        }
    }

    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) 
    {
        var c = ctx.Clone();
        c.Run<APM_PageObject_Type, PdfDictionary>(new CallStack(), obj, null);
        if (c.Errors.Any())
        {
            return false;
        }
        return true;
    }

    public static HashSet<string> AllowedFields_10 { get; } = new HashSet<string> 
    {
        "Type", "Parent", "Resources", "MediaBox", "CropBox", "Contents", "Rotate", "Thumb", "Annots"
    };
    public static HashSet<string> AllowedFields_11 { get; } = new HashSet<string> 
    {
        "Type", "Parent", "Resources", "MediaBox", "CropBox", "Contents", "Rotate", "Thumb", "B", "Dur", "Trans", "Annots", "Hid"
    };
    public static HashSet<string> AllowedFields_12 { get; } = new HashSet<string> 
    {
        "Type", "Parent", "Resources", "MediaBox", "CropBox", "Contents", "Rotate", "Thumb", "B", "Dur", "Trans", "Annots", "AA", "Hid"
    };
    public static HashSet<string> AllowedFields_13 { get; } = new HashSet<string> 
    {
        "Type", "Parent", "LastModified", "Resources", "MediaBox", "CropBox", "BleedBox", "TrimBox", "ArtBox", "Contents", "Rotate", "Thumb", "B", "Dur", "Trans", "Annots", "AA", "PieceInfo", "StructParents", "ID", "PZ", "SeparationInfo"
    };
    public static HashSet<string> AllowedFields_14 { get; } = new HashSet<string> 
    {
        "Type", "Parent", "LastModified", "Resources", "MediaBox", "CropBox", "BleedBox", "TrimBox", "ArtBox", "BoxColorInfo", "Contents", "Rotate", "Group", "Thumb", "B", "Dur", "Trans", "Annots", "AA", "Metadata", "PieceInfo", "StructParents", "ID", "PZ", "SeparationInfo"
    };
    public static HashSet<string> AllowedFields_15 { get; } = new HashSet<string> 
    {
        "Type", "Parent", "LastModified", "Resources", "MediaBox", "CropBox", "BleedBox", "TrimBox", "ArtBox", "BoxColorInfo", "Contents", "Rotate", "Group", "Thumb", "B", "Dur", "Trans", "Annots", "AA", "Metadata", "PieceInfo", "StructParents", "ID", "PZ", "SeparationInfo", "Tabs", "TemplateInstantiated", "PresSteps"
    };
    public static HashSet<string> AllowedFields_16 { get; } = new HashSet<string> 
    {
        "Type", "Parent", "LastModified", "Resources", "MediaBox", "CropBox", "BleedBox", "TrimBox", "ArtBox", "BoxColorInfo", "Contents", "Rotate", "Group", "Thumb", "B", "Dur", "Trans", "Annots", "AA", "Metadata", "PieceInfo", "StructParents", "ID", "PZ", "SeparationInfo", "Tabs", "TemplateInstantiated", "PresSteps", "UserUnit", "VP"
    };
    public static HashSet<string> AllowedFields_17 { get; } = new HashSet<string> 
    {
        "Type", "Parent", "LastModified", "Resources", "MediaBox", "CropBox", "BleedBox", "TrimBox", "ArtBox", "BoxColorInfo", "Contents", "Rotate", "Group", "Thumb", "B", "Dur", "Trans", "Annots", "AA", "Metadata", "PieceInfo", "StructParents", "ID", "PZ", "SeparationInfo", "Tabs", "TemplateInstantiated", "PresSteps", "UserUnit", "VP"
    };
    public static HashSet<string> AllowedFields_18 { get; } = new HashSet<string> 
    {
        "Type", "Parent", "LastModified", "Resources", "MediaBox", "CropBox", "BleedBox", "TrimBox", "ArtBox", "BoxColorInfo", "Contents", "Rotate", "Group", "Thumb", "B", "Dur", "Trans", "Annots", "AA", "Metadata", "PieceInfo", "StructParents", "ID", "PZ", "SeparationInfo", "Tabs", "TemplateInstantiated", "PresSteps", "UserUnit", "VP"
    };
    public static HashSet<string> AllowedFields_19 { get; } = new HashSet<string> 
    {
        "Type", "Parent", "LastModified", "Resources", "MediaBox", "CropBox", "BleedBox", "TrimBox", "ArtBox", "BoxColorInfo", "Contents", "Rotate", "Group", "Thumb", "B", "Dur", "Trans", "Annots", "AA", "Metadata", "PieceInfo", "StructParents", "ID", "PZ", "SeparationInfo", "Tabs", "TemplateInstantiated", "PresSteps", "UserUnit", "VP"
    };
    public static HashSet<string> AllowedFields_20 { get; } = new HashSet<string> 
    {
        "Type", "Parent", "LastModified", "Resources", "MediaBox", "CropBox", "BleedBox", "TrimBox", "ArtBox", "BoxColorInfo", "Contents", "Rotate", "Group", "Thumb", "B", "Dur", "Trans", "Annots", "AA", "Metadata", "PieceInfo", "StructParents", "ID", "PZ", "SeparationInfo", "Tabs", "TemplateInstantiated", "PresSteps", "UserUnit", "VP", "AF", "OutputIntents"
    };
    


}

/// <summary>
/// PageObject_Type Table 31
/// </summary>
internal partial class APM_PageObject_Type : APM_PageObject_Type_Base
{
}


internal partial class APM_PageObject_Type_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "PageObject_Type";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.0m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetRequired<PdfName, APM_PageObject_Type>(obj, "Type", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        {
        
        
        if (!(val == "Page" || val == "Template")) 
        {
            ctx.Fail<APM_PageObject_Type>($"Invalid value {val}, allowed are: [Page,Template]");
        }
        }
        // no linked objects
        
    }


}

/// <summary>
/// PageObject_Parent 
/// </summary>
internal partial class APM_PageObject_Parent : APM_PageObject_Parent_Base
{
}


internal partial class APM_PageObject_Parent_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "PageObject_Parent";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.0m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        PdfDictionary? val;
        {
            var Type = obj.Get("Type");
            if (!eq(Type,"Template")) {
                val = ctx.GetRequired<PdfDictionary, APM_PageObject_Parent>(obj, "Parent", IndirectRequirement.MustBeIndirect);
            } else {
                val = ctx.GetOptional<PdfDictionary, APM_PageObject_Parent>(obj, "Parent", IndirectRequirement.MustBeIndirect);
            }
            if (val == null) { return; }
        }
        // TODO special case
        // no value restrictions
        if (APM_PageTreeNode.MatchesType(ctx, val)) 
        {
            ctx.Run<APM_PageTreeNode, PdfDictionary>(stack, val, obj);
        } else if (APM_PageTreeNodeRoot.MatchesType(ctx, val)) 
        {
            ctx.Run<APM_PageTreeNodeRoot, PdfDictionary>(stack, val, obj);
        }else 
        {
            ctx.Fail<APM_PageObject_Parent>("Parent did not match any allowable types: '[PageTreeNode,PageTreeNodeRoot]'");
        }
        
    }


}

/// <summary>
/// PageObject_LastModified 
/// </summary>
internal partial class APM_PageObject_LastModified : APM_PageObject_LastModified_Base
{
}


internal partial class APM_PageObject_LastModified_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "PageObject_LastModified";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.3m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        PdfString? val;
        {
            
            if (obj.ContainsKey("PieceInfo")) {
                val = ctx.GetRequired<PdfString, APM_PageObject_LastModified>(obj, "LastModified", IndirectRequirement.Either);
            } else {
                val = ctx.GetOptional<PdfString, APM_PageObject_LastModified>(obj, "LastModified", IndirectRequirement.Either);
            }
            if (val == null) { return; }
        }
        // no special cases
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// PageObject_Resources Inheritable from Parent
/// </summary>
internal partial class APM_PageObject_Resources : APM_PageObject_Resources_Base
{
}


internal partial class APM_PageObject_Resources_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "PageObject_Resources";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.0m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetRequired<PdfDictionary, APM_PageObject_Resources>(obj, "Resources", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        ctx.Run<APM_Resource, PdfDictionary>(stack, val, obj);
        
    }


}

/// <summary>
/// PageObject_MediaBox Inheritable from Parent
/// </summary>
internal partial class APM_PageObject_MediaBox : APM_PageObject_MediaBox_Base
{
}


internal partial class APM_PageObject_MediaBox_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "PageObject_MediaBox";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.0m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetRequired<PdfArray, APM_PageObject_MediaBox>(obj, "MediaBox", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// PageObject_CropBox Inheritable from Parent
/// </summary>
internal partial class APM_PageObject_CropBox : APM_PageObject_CropBox_Base
{
}


internal partial class APM_PageObject_CropBox_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "PageObject_CropBox";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.0m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfArray, APM_PageObject_CropBox>(obj, "CropBox", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// PageObject_BleedBox Inheritable from Parent
/// </summary>
internal partial class APM_PageObject_BleedBox : APM_PageObject_BleedBox_Base
{
}


internal partial class APM_PageObject_BleedBox_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "PageObject_BleedBox";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.3m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfArray, APM_PageObject_BleedBox>(obj, "BleedBox", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// PageObject_TrimBox 
/// </summary>
internal partial class APM_PageObject_TrimBox : APM_PageObject_TrimBox_Base
{
}


internal partial class APM_PageObject_TrimBox_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "PageObject_TrimBox";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.3m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfArray, APM_PageObject_TrimBox>(obj, "TrimBox", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// PageObject_ArtBox 
/// </summary>
internal partial class APM_PageObject_ArtBox : APM_PageObject_ArtBox_Base
{
}


internal partial class APM_PageObject_ArtBox_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "PageObject_ArtBox";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.3m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfArray, APM_PageObject_ArtBox>(obj, "ArtBox", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// PageObject_BoxColorInfo 
/// </summary>
internal partial class APM_PageObject_BoxColorInfo : APM_PageObject_BoxColorInfo_Base
{
}


internal partial class APM_PageObject_BoxColorInfo_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "PageObject_BoxColorInfo";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.4m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfDictionary, APM_PageObject_BoxColorInfo>(obj, "BoxColorInfo", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        ctx.Run<APM_BoxColorInfo, PdfDictionary>(stack, val, obj);
        
    }


}

/// <summary>
/// PageObject_Contents 
/// </summary>
internal partial class APM_PageObject_Contents : APM_PageObject_Contents_Base
{
}


internal partial class APM_PageObject_Contents_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "PageObject_Contents";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.0m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var (utval, wasIR) = ctx.GetOptional<APM_PageObject_Contents>(obj, "Contents", IndirectRequirement.Either);
        if (utval == null) { return; }
        switch (utval.Type) 
        {
            case PdfObjectType.ArrayObj:
                {
                    var val =  (PdfArray)utval;
                    // no indirect obj reqs
                    // no special cases
                    // no value restrictions
                    ctx.Run<APM_ArrayOfStreamsGeneral, PdfArray>(stack, val, obj);
                    return;
                }
            case PdfObjectType.StreamObj:
                {
                    var val =  (PdfStream)utval;
                    if (!wasIR) { ctx.Fail<APM_PageObject_Contents>("Contents is required to be indirect when a stream"); return; }
                    // no special cases
                    // no value restrictions
                    ctx.Run<APM_Stream, PdfDictionary>(stack, val.Dictionary, obj);
                    return;
                }
            
            default:
                ctx.Fail<APM_PageObject_Contents>("Contents is required to one of 'array;stream', was " + utval.Type);
                return;
        }
    }


}

/// <summary>
/// PageObject_Rotate Inheritable from Parent
/// </summary>
internal partial class APM_PageObject_Rotate : APM_PageObject_Rotate_Base
{
}


internal partial class APM_PageObject_Rotate_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "PageObject_Rotate";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.0m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfIntNumber, APM_PageObject_Rotate>(obj, "Rotate", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        {
        
        IPdfObject @Rotate = val;
        if (!(eq(mod(@Rotate,90),0))) 
        {
            ctx.Fail<APM_PageObject_Rotate>($"Invalid value {val}, allowed are: [fn:Eval((@Rotate mod 90)==0)]");
        }
        }
        // no linked objects
        
    }


}

/// <summary>
/// PageObject_Group 
/// </summary>
internal partial class APM_PageObject_Group : APM_PageObject_Group_Base
{
}


internal partial class APM_PageObject_Group_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "PageObject_Group";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.4m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfDictionary, APM_PageObject_Group>(obj, "Group", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        ctx.Run<APM_GroupAttributes, PdfDictionary>(stack, val, obj);
        
    }


}

/// <summary>
/// PageObject_Thumb 
/// </summary>
internal partial class APM_PageObject_Thumb : APM_PageObject_Thumb_Base
{
}


internal partial class APM_PageObject_Thumb_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "PageObject_Thumb";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.0m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfStream, APM_PageObject_Thumb>(obj, "Thumb", IndirectRequirement.MustBeIndirect);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        ctx.Run<APM_Thumbnail, PdfDictionary>(stack, val.Dictionary, obj);
        
    }


}

/// <summary>
/// PageObject_B 
/// </summary>
internal partial class APM_PageObject_B : APM_PageObject_B_Base
{
}


internal partial class APM_PageObject_B_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "PageObject_B";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.1m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfArray, APM_PageObject_B>(obj, "B", IndirectRequirement.Either);
        if (val == null) { return; }
        // TODO special case
        // no value restrictions
        ctx.Run<APM_ArrayOfBeads, PdfArray>(stack, val, obj);
        
    }


}

/// <summary>
/// PageObject_Dur 
/// </summary>
internal partial class APM_PageObject_Dur : APM_PageObject_Dur_Base
{
}


internal partial class APM_PageObject_Dur_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "PageObject_Dur";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.1m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfNumber, APM_PageObject_Dur>(obj, "Dur", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// PageObject_Trans 
/// </summary>
internal partial class APM_PageObject_Trans : APM_PageObject_Trans_Base
{
}


internal partial class APM_PageObject_Trans_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "PageObject_Trans";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.1m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfDictionary, APM_PageObject_Trans>(obj, "Trans", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        ctx.Run<APM_Transition, PdfDictionary>(stack, val, obj);
        
    }


}

/// <summary>
/// PageObject_Annots 
/// </summary>
internal partial class APM_PageObject_Annots : APM_PageObject_Annots_Base
{
}


internal partial class APM_PageObject_Annots_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "PageObject_Annots";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.0m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfArray, APM_PageObject_Annots>(obj, "Annots", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        ctx.Run<APM_ArrayOfAnnots, PdfArray>(stack, val, obj);
        
    }


}

/// <summary>
/// PageObject_AA 
/// </summary>
internal partial class APM_PageObject_AA : APM_PageObject_AA_Base
{
}


internal partial class APM_PageObject_AA_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "PageObject_AA";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.2m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfDictionary, APM_PageObject_AA>(obj, "AA", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        ctx.Run<APM_AddActionPageObject, PdfDictionary>(stack, val, obj);
        
    }


}

/// <summary>
/// PageObject_Metadata 
/// </summary>
internal partial class APM_PageObject_Metadata : APM_PageObject_Metadata_Base
{
}


internal partial class APM_PageObject_Metadata_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "PageObject_Metadata";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.4m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfStream, APM_PageObject_Metadata>(obj, "Metadata", IndirectRequirement.MustBeIndirect);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        ctx.Run<APM_Metadata, PdfDictionary>(stack, val.Dictionary, obj);
        
    }


}

/// <summary>
/// PageObject_PieceInfo 
/// </summary>
internal partial class APM_PageObject_PieceInfo : APM_PageObject_PieceInfo_Base
{
}


internal partial class APM_PageObject_PieceInfo_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "PageObject_PieceInfo";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.3m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfDictionary, APM_PageObject_PieceInfo>(obj, "PieceInfo", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        ctx.Run<APM_PagePiece, PdfDictionary>(stack, val, obj);
        
    }


}

/// <summary>
/// PageObject_StructParents Table 359
/// </summary>
internal partial class APM_PageObject_StructParents : APM_PageObject_StructParents_Base
{
}


internal partial class APM_PageObject_StructParents_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "PageObject_StructParents";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.3m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        PdfIntNumber? val;
        {
            
            if (PageContainsStructContentItems(obj)) {
                val = ctx.GetRequired<PdfIntNumber, APM_PageObject_StructParents>(obj, "StructParents", IndirectRequirement.Either);
            } else {
                val = ctx.GetOptional<PdfIntNumber, APM_PageObject_StructParents>(obj, "StructParents", IndirectRequirement.Either);
            }
            if (val == null) { return; }
        }
        // no special cases
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// PageObject_ID https://github.com/pdf-association/pdf-issues/issues/106
/// </summary>
internal partial class APM_PageObject_ID : APM_PageObject_ID_Base
{
}


internal partial class APM_PageObject_ID_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "PageObject_ID";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.3m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfString, APM_PageObject_ID>(obj, "ID", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// PageObject_PZ 
/// </summary>
internal partial class APM_PageObject_PZ : APM_PageObject_PZ_Base
{
}


internal partial class APM_PageObject_PZ_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "PageObject_PZ";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.3m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfNumber, APM_PageObject_PZ>(obj, "PZ", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// PageObject_SeparationInfo 
/// </summary>
internal partial class APM_PageObject_SeparationInfo : APM_PageObject_SeparationInfo_Base
{
}


internal partial class APM_PageObject_SeparationInfo_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "PageObject_SeparationInfo";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.3m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfDictionary, APM_PageObject_SeparationInfo>(obj, "SeparationInfo", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        ctx.Run<APM_Separation, PdfDictionary>(stack, val, obj);
        
    }


}

/// <summary>
/// PageObject_Tabs 
/// </summary>
internal partial class APM_PageObject_Tabs : APM_PageObject_Tabs_Base
{
}


internal partial class APM_PageObject_Tabs_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "PageObject_Tabs";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.5m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfName, APM_PageObject_Tabs>(obj, "Tabs", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        {
        
        
        if (!(val == "R" || val == "C" || val == "S" || (ctx.Version == 1.7m && (ctx.Extensions.Contains("ADBE_Extn3") && val == "A")) || (ctx.Version == 1.7m && (ctx.Extensions.Contains("ADBE_Extn3") && val == "W")) || ctx.Version >= 2.0m && val == "A" || ctx.Version >= 2.0m && val == "W")) 
        {
            ctx.Fail<APM_PageObject_Tabs>($"Invalid value {val}, allowed are: [R,C,S,fn:IsPDFVersion(1.7,fn:Extension(ADBE_Extn3,A)),fn:IsPDFVersion(1.7,fn:Extension(ADBE_Extn3,W)),fn:SinceVersion(2.0,A),fn:SinceVersion(2.0,W)]");
        }
        }
        // no linked objects
        
    }


}

/// <summary>
/// PageObject_TemplateInstantiated 
/// </summary>
internal partial class APM_PageObject_TemplateInstantiated : APM_PageObject_TemplateInstantiated_Base
{
}


internal partial class APM_PageObject_TemplateInstantiated_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "PageObject_TemplateInstantiated";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.5m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        PdfName? val;
        {
            var trailerCatalogNamesPages = obj.Get("trailer")?.Get("Catalog")?.Get("Names")?.Get("Pages");
            var trailerCatalogNamesTemplates = obj.Get("trailer")?.Get("Catalog")?.Get("Names")?.Get("Templates");
            if ((InNameTree(trailerCatalogNamesPages)||InNameTree(trailerCatalogNamesTemplates))) {
                val = ctx.GetRequired<PdfName, APM_PageObject_TemplateInstantiated>(obj, "TemplateInstantiated", IndirectRequirement.Either);
            } else {
                val = ctx.GetOptional<PdfName, APM_PageObject_TemplateInstantiated>(obj, "TemplateInstantiated", IndirectRequirement.Either);
            }
            if (val == null) { return; }
        }
        // no special cases
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// PageObject_PresSteps 
/// </summary>
internal partial class APM_PageObject_PresSteps : APM_PageObject_PresSteps_Base
{
}


internal partial class APM_PageObject_PresSteps_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "PageObject_PresSteps";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.5m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfDictionary, APM_PageObject_PresSteps>(obj, "PresSteps", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        ctx.Run<APM_NavNode, PdfDictionary>(stack, val, obj);
        
    }


}

/// <summary>
/// PageObject_UserUnit 
/// </summary>
internal partial class APM_PageObject_UserUnit : APM_PageObject_UserUnit_Base
{
}


internal partial class APM_PageObject_UserUnit_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "PageObject_UserUnit";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.6m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfNumber, APM_PageObject_UserUnit>(obj, "UserUnit", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// PageObject_VP 
/// </summary>
internal partial class APM_PageObject_VP : APM_PageObject_VP_Base
{
}


internal partial class APM_PageObject_VP_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "PageObject_VP";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.6m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfArray, APM_PageObject_VP>(obj, "VP", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        ctx.Run<APM_ArrayOfViewports, PdfArray>(stack, val, obj);
        
    }


}

/// <summary>
/// PageObject_AF 
/// </summary>
internal partial class APM_PageObject_AF : APM_PageObject_AF_Base
{
}


internal partial class APM_PageObject_AF_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "PageObject_AF";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 2.0m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var (utval, wasIR) = ctx.GetOptional<APM_PageObject_AF>(obj, "AF", IndirectRequirement.Either);
        if (utval == null) { return; }
        switch (utval.Type) 
        {
            case PdfObjectType.ArrayObj:
                {
                    var val =  (PdfArray)utval;
                    // no indirect obj reqs
                    // no special cases
                    // no value restrictions
                    ctx.Run<APM_ArrayOfFileSpecifications, PdfArray>(stack, val, obj);
                    return;
                }
            case PdfObjectType.DictionaryObj:
                {
                    var val =  (PdfDictionary)utval;
                    // no indirect obj reqs
                    // no special cases
                    // no value restrictions
                    ctx.Run<APM_FileSpecification, PdfDictionary>(stack, val, obj);
                    return;
                }
            
            default:
                ctx.Fail<APM_PageObject_AF>("AF is required to one of 'array;dictionary', was " + utval.Type);
                return;
        }
    }


}

/// <summary>
/// PageObject_OutputIntents 
/// </summary>
internal partial class APM_PageObject_OutputIntents : APM_PageObject_OutputIntents_Base
{
}


internal partial class APM_PageObject_OutputIntents_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "PageObject_OutputIntents";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 2.0m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfArray, APM_PageObject_OutputIntents>(obj, "OutputIntents", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        ctx.Run<APM_ArrayOfOutputIntents, PdfArray>(stack, val, obj);
        
    }


}

/// <summary>
/// PageObject_DPart 
/// </summary>
internal partial class APM_PageObject_DPart : APM_PageObject_DPart_Base
{
}


internal partial class APM_PageObject_DPart_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "PageObject_DPart";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return false; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfDictionary, APM_PageObject_DPart>(obj, "DPart", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        ctx.Run<APM_DPart, PdfDictionary>(stack, val, obj);
        
    }


}

/// <summary>
/// PageObject_Hid 
/// </summary>
internal partial class APM_PageObject_Hid : APM_PageObject_Hid_Base
{
}


internal partial class APM_PageObject_Hid_Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "PageObject_Hid";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.1m && version < 1.3m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfBoolean, APM_PageObject_Hid>(obj, "Hid", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        // no linked objects
        
    }


}

