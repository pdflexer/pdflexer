// AUTOGENERATED DO NOT MODIFY

using PdfLexer;
using static PdfLexer.Validation.MathUtil;

namespace PdfLexer.Validation;

using System.Linq;

internal partial class APM_GraphicsStateParameter : APM_GraphicsStateParameter__Base
{
}

internal partial class APM_GraphicsStateParameter__Base : ISpecification<PdfDictionary>
{
    public static bool RuleGroup() { return true; }
    public static string Name { get; } = "GraphicsStateParameter";
    public static bool AppliesTo(decimal version, List<string> extensions) => true; // managed by links
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        ctx.Run<APM_GraphicsStateParameter_Type, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_GraphicsStateParameter_LW, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_GraphicsStateParameter_LC, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_GraphicsStateParameter_LJ, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_GraphicsStateParameter_ML, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_GraphicsStateParameter_D, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_GraphicsStateParameter_RI, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_GraphicsStateParameter_OP, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_GraphicsStateParameter_op, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_GraphicsStateParameter_OPM, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_GraphicsStateParameter_Font, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_GraphicsStateParameter_BG, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_GraphicsStateParameter_BG2, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_GraphicsStateParameter_UCR, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_GraphicsStateParameter_UCR2, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_GraphicsStateParameter_TR, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_GraphicsStateParameter_TR2, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_GraphicsStateParameter_HT, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_GraphicsStateParameter_FL, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_GraphicsStateParameter_SM, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_GraphicsStateParameter_SA, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_GraphicsStateParameter_BM, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_GraphicsStateParameter_SMask, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_GraphicsStateParameter_CA, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_GraphicsStateParameter_ca, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_GraphicsStateParameter_AIS, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_GraphicsStateParameter_TK, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_GraphicsStateParameter_UseBlackPtComp, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_GraphicsStateParameter_HTO, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_GraphicsStateParameter_HTP, PdfDictionary>(stack, obj, parent);
        switch (ctx.Version) {
            case 1.2m:
                foreach (var extra in obj.Keys.Where(x=> !AllowedFields_12.Contains(x)))
                {
                    ctx.Fail<APM_GraphicsStateParameter>($"Unknown field {extra} for version 1.2");
                }
                break;
            case 1.3m:
                foreach (var extra in obj.Keys.Where(x=> !AllowedFields_13.Contains(x)))
                {
                    ctx.Fail<APM_GraphicsStateParameter>($"Unknown field {extra} for version 1.3");
                }
                break;
            case 1.4m:
                foreach (var extra in obj.Keys.Where(x=> !AllowedFields_14.Contains(x)))
                {
                    ctx.Fail<APM_GraphicsStateParameter>($"Unknown field {extra} for version 1.4");
                }
                break;
            case 1.5m:
                foreach (var extra in obj.Keys.Where(x=> !AllowedFields_15.Contains(x)))
                {
                    ctx.Fail<APM_GraphicsStateParameter>($"Unknown field {extra} for version 1.5");
                }
                break;
            case 1.6m:
                foreach (var extra in obj.Keys.Where(x=> !AllowedFields_16.Contains(x)))
                {
                    ctx.Fail<APM_GraphicsStateParameter>($"Unknown field {extra} for version 1.6");
                }
                break;
            case 1.7m:
                foreach (var extra in obj.Keys.Where(x=> !AllowedFields_17.Contains(x)))
                {
                    ctx.Fail<APM_GraphicsStateParameter>($"Unknown field {extra} for version 1.7");
                }
                break;
            case 1.8m:
                foreach (var extra in obj.Keys.Where(x=> !AllowedFields_18.Contains(x)))
                {
                    ctx.Fail<APM_GraphicsStateParameter>($"Unknown field {extra} for version 1.8");
                }
                break;
            case 1.9m:
                foreach (var extra in obj.Keys.Where(x=> !AllowedFields_19.Contains(x)))
                {
                    ctx.Fail<APM_GraphicsStateParameter>($"Unknown field {extra} for version 1.9");
                }
                break;
            case 2.0m:
                foreach (var extra in obj.Keys.Where(x=> !AllowedFields_20.Contains(x)))
                {
                    ctx.Fail<APM_GraphicsStateParameter>($"Unknown field {extra} for version 2.0");
                }
                break;
            default:
                break;
        }
    }

    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) 
    {
        var c = ctx.Clone();
        c.Run<APM_GraphicsStateParameter_Type, PdfDictionary>(new CallStack(), obj, null);
        if (c.Errors.Any())
        {
            return false;
        }
        return true;
    }

    public static HashSet<string> AllowedFields_12 { get; } = new HashSet<string> 
    {
        "Type", "OP", "BG", "UCR", "TR", "HT", "SA", "HTP", "AAPL:AA", "AAPL:ST"
    };
    public static HashSet<string> AllowedFields_13 { get; } = new HashSet<string> 
    {
        "Type", "LW", "LC", "LJ", "ML", "D", "RI", "OP", "op", "OPM", "Font", "BG", "BG2", "UCR", "UCR2", "TR", "TR2", "HT", "FL", "SM", "SA", "AAPL:AA", "AAPL:ST"
    };
    public static HashSet<string> AllowedFields_14 { get; } = new HashSet<string> 
    {
        "Type", "LW", "LC", "LJ", "ML", "D", "RI", "OP", "op", "OPM", "Font", "BG", "BG2", "UCR", "UCR2", "TR", "TR2", "HT", "FL", "SM", "SA", "BM", "SMask", "CA", "ca", "AIS", "TK", "AAPL:AA", "AAPL:ST"
    };
    public static HashSet<string> AllowedFields_15 { get; } = new HashSet<string> 
    {
        "Type", "LW", "LC", "LJ", "ML", "D", "RI", "OP", "op", "OPM", "Font", "BG", "BG2", "UCR", "UCR2", "TR", "TR2", "HT", "FL", "SM", "SA", "BM", "SMask", "CA", "ca", "AIS", "TK", "AAPL:AA", "AAPL:ST"
    };
    public static HashSet<string> AllowedFields_16 { get; } = new HashSet<string> 
    {
        "Type", "LW", "LC", "LJ", "ML", "D", "RI", "OP", "op", "OPM", "Font", "BG", "BG2", "UCR", "UCR2", "TR", "TR2", "HT", "FL", "SM", "SA", "BM", "SMask", "CA", "ca", "AIS", "TK", "AAPL:AA", "AAPL:ST"
    };
    public static HashSet<string> AllowedFields_17 { get; } = new HashSet<string> 
    {
        "Type", "LW", "LC", "LJ", "ML", "D", "RI", "OP", "op", "OPM", "Font", "BG", "BG2", "UCR", "UCR2", "TR", "TR2", "HT", "FL", "SM", "SA", "BM", "SMask", "CA", "ca", "AIS", "TK", "AAPL:AA", "AAPL:ST"
    };
    public static HashSet<string> AllowedFields_18 { get; } = new HashSet<string> 
    {
        "Type", "LW", "LC", "LJ", "ML", "D", "RI", "OP", "op", "OPM", "Font", "BG", "BG2", "UCR", "UCR2", "TR", "TR2", "HT", "FL", "SM", "SA", "BM", "SMask", "CA", "ca", "AIS", "TK", "AAPL:AA", "AAPL:ST"
    };
    public static HashSet<string> AllowedFields_19 { get; } = new HashSet<string> 
    {
        "Type", "LW", "LC", "LJ", "ML", "D", "RI", "OP", "op", "OPM", "Font", "BG", "BG2", "UCR", "UCR2", "TR", "TR2", "HT", "FL", "SM", "SA", "BM", "SMask", "CA", "ca", "AIS", "TK", "AAPL:AA", "AAPL:ST"
    };
    public static HashSet<string> AllowedFields_20 { get; } = new HashSet<string> 
    {
        "Type", "LW", "LC", "LJ", "ML", "D", "RI", "OP", "op", "OPM", "Font", "BG", "BG2", "UCR", "UCR2", "HT", "FL", "SM", "SA", "BM", "SMask", "CA", "ca", "AIS", "TK", "UseBlackPtComp", "HTO", "AAPL:AA", "AAPL:ST"
    };
    


}

/// <summary>
/// GraphicsStateParameter_Type Table 57
/// </summary>
internal partial class APM_GraphicsStateParameter_Type : APM_GraphicsStateParameter_Type__Base
{
}


internal partial class APM_GraphicsStateParameter_Type__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "GraphicsStateParameter_Type";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.2m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfName, APM_GraphicsStateParameter_Type>(obj, "Type", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        
        
        if (!(val == "ExtGState")) 
        {
            ctx.Fail<APM_GraphicsStateParameter_Type>($"Invalid value {val}, allowed are: [ExtGState]");
        }
        // no linked objects
        
    }


}

/// <summary>
/// GraphicsStateParameter_LW 
/// </summary>
internal partial class APM_GraphicsStateParameter_LW : APM_GraphicsStateParameter_LW__Base
{
}


internal partial class APM_GraphicsStateParameter_LW__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "GraphicsStateParameter_LW";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.3m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfNumber, APM_GraphicsStateParameter_LW>(obj, "LW", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        
        var LW = obj.Get("LW");
        if (!(gte(LW,0))) 
        {
            ctx.Fail<APM_GraphicsStateParameter_LW>($"Invalid value {val}, allowed are: [fn:Eval(@LW>=0)]");
        }
        // no linked objects
        
    }


}

/// <summary>
/// GraphicsStateParameter_LC Table 53
/// </summary>
internal partial class APM_GraphicsStateParameter_LC : APM_GraphicsStateParameter_LC__Base
{
}


internal partial class APM_GraphicsStateParameter_LC__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "GraphicsStateParameter_LC";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.3m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfIntNumber, APM_GraphicsStateParameter_LC>(obj, "LC", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        
        var LC = obj.Get("LC");
        if (!((gte(LC,0)&&lte(LC,2)))) 
        {
            ctx.Fail<APM_GraphicsStateParameter_LC>($"Invalid value {val}, allowed are: [fn:Eval((@LC>=0) && (@LC<=2))]");
        }
        // no linked objects
        
    }


}

/// <summary>
/// GraphicsStateParameter_LJ Table 54
/// </summary>
internal partial class APM_GraphicsStateParameter_LJ : APM_GraphicsStateParameter_LJ__Base
{
}


internal partial class APM_GraphicsStateParameter_LJ__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "GraphicsStateParameter_LJ";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.3m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfIntNumber, APM_GraphicsStateParameter_LJ>(obj, "LJ", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        
        var LJ = obj.Get("LJ");
        if (!((gte(LJ,0)&&lte(LJ,2)))) 
        {
            ctx.Fail<APM_GraphicsStateParameter_LJ>($"Invalid value {val}, allowed are: [fn:Eval((@LJ>=0) && (@LJ<=2))]");
        }
        // no linked objects
        
    }


}

/// <summary>
/// GraphicsStateParameter_ML 
/// </summary>
internal partial class APM_GraphicsStateParameter_ML : APM_GraphicsStateParameter_ML__Base
{
}


internal partial class APM_GraphicsStateParameter_ML__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "GraphicsStateParameter_ML";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.3m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfNumber, APM_GraphicsStateParameter_ML>(obj, "ML", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        
        var ML = obj.Get("ML");
        if (!(gte(ML,1))) 
        {
            ctx.Fail<APM_GraphicsStateParameter_ML>($"Invalid value {val}, allowed are: [fn:Eval(@ML>=1)]");
        }
        // no linked objects
        
    }


}

/// <summary>
/// GraphicsStateParameter_D 
/// </summary>
internal partial class APM_GraphicsStateParameter_D : APM_GraphicsStateParameter_D__Base
{
}


internal partial class APM_GraphicsStateParameter_D__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "GraphicsStateParameter_D";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.3m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfArray, APM_GraphicsStateParameter_D>(obj, "D", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        ctx.Run<APM_ArrayOfGSPDashPatterns, PdfArray>(stack, val, obj);
        
    }


}

/// <summary>
/// GraphicsStateParameter_RI Table 69
/// </summary>
internal partial class APM_GraphicsStateParameter_RI : APM_GraphicsStateParameter_RI__Base
{
}


internal partial class APM_GraphicsStateParameter_RI__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "GraphicsStateParameter_RI";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.3m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfName, APM_GraphicsStateParameter_RI>(obj, "RI", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        
        
        if (!(val == "AbsoluteColorimetric" || val == "RelativeColorimetric" || val == "Saturation" || val == "Perceptual")) 
        {
            ctx.Fail<APM_GraphicsStateParameter_RI>($"Invalid value {val}, allowed are: [AbsoluteColorimetric,RelativeColorimetric,Saturation,Perceptual]");
        }
        // no linked objects
        
    }


}

/// <summary>
/// GraphicsStateParameter_OP 
/// </summary>
internal partial class APM_GraphicsStateParameter_OP : APM_GraphicsStateParameter_OP__Base
{
}


internal partial class APM_GraphicsStateParameter_OP__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "GraphicsStateParameter_OP";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.2m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfBoolean, APM_GraphicsStateParameter_OP>(obj, "OP", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// GraphicsStateParameter_op 
/// </summary>
internal partial class APM_GraphicsStateParameter_op : APM_GraphicsStateParameter_op__Base
{
}


internal partial class APM_GraphicsStateParameter_op__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "GraphicsStateParameter_op";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.3m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfBoolean, APM_GraphicsStateParameter_op>(obj, "op", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// GraphicsStateParameter_OPM 
/// </summary>
internal partial class APM_GraphicsStateParameter_OPM : APM_GraphicsStateParameter_OPM__Base
{
}


internal partial class APM_GraphicsStateParameter_OPM__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "GraphicsStateParameter_OPM";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.3m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfIntNumber, APM_GraphicsStateParameter_OPM>(obj, "OPM", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        
        var OPM = obj.Get("OPM");
        if (!((gte(OPM,0)&&lte(OPM,1)))) 
        {
            ctx.Fail<APM_GraphicsStateParameter_OPM>($"Invalid value {val}, allowed are: [fn:Eval((@OPM>=0) && (@OPM<=1))]");
        }
        // no linked objects
        
    }


}

/// <summary>
/// GraphicsStateParameter_Font 
/// </summary>
internal partial class APM_GraphicsStateParameter_Font : APM_GraphicsStateParameter_Font__Base
{
}


internal partial class APM_GraphicsStateParameter_Font__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "GraphicsStateParameter_Font";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.3m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfArray, APM_GraphicsStateParameter_Font>(obj, "Font", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        ctx.Run<APM_ArrayOfFontAndSize, PdfArray>(stack, val, obj);
        
    }


}

/// <summary>
/// GraphicsStateParameter_BG 
/// </summary>
internal partial class APM_GraphicsStateParameter_BG : APM_GraphicsStateParameter_BG__Base
{
}


internal partial class APM_GraphicsStateParameter_BG__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "GraphicsStateParameter_BG";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.2m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var (utval, wasIR) = ctx.GetOptional<APM_GraphicsStateParameter_BG>(obj, "BG", IndirectRequirement.Either);
        if (utval == null) { return; }
        switch (utval.Type) 
        {
            case PdfObjectType.StreamObj:
                {
                    var val =  (PdfStream)utval;
                    if (!wasIR) { ctx.Fail<APM_GraphicsStateParameter_BG>("BG is required to be indirect when a stream"); return; }
                    // no special cases
                    // no value restrictions
                    if (APM_FunctionType0.MatchesType(ctx, val.Dictionary)) 
                    {
                        ctx.Run<APM_FunctionType0, PdfDictionary>(stack, val.Dictionary, obj);
                    } else if ((ctx.Version >= 1.3m && APM_FunctionType4.MatchesType(ctx, val.Dictionary))) 
                    {
                        ctx.Run<APM_FunctionType4, PdfDictionary>(stack, val.Dictionary, obj);
                    }else 
                    {
                        ctx.Fail<APM_GraphicsStateParameter_BG>("BG did not match any allowable types: '[FunctionType0,fn:SinceVersion(1.3,FunctionType4)]'");
                    }
                    return;
                }
            case PdfObjectType.DictionaryObj:
                {
                    if (!(ctx.Version >= 1.3m)) 
                    {
                        ctx.Fail<APM_GraphicsStateParameter_BG>("BG was type dictionary but not allowed for current conditions: 'fn:SinceVersion(1.3,dictionary)'");
                    }
                    var val =  (PdfDictionary)utval;
                    // no indirect obj reqs
                    // no special cases
                    // no value restrictions
                    if ((ctx.Version >= 1.3m && APM_FunctionType2.MatchesType(ctx, val))) 
                    {
                        ctx.Run<APM_FunctionType2, PdfDictionary>(stack, val, obj);
                    } else if ((ctx.Version >= 1.3m && APM_FunctionType3.MatchesType(ctx, val))) 
                    {
                        ctx.Run<APM_FunctionType3, PdfDictionary>(stack, val, obj);
                    }else 
                    {
                        ctx.Fail<APM_GraphicsStateParameter_BG>("BG did not match any allowable types: '[fn:SinceVersion(1.3,FunctionType2),fn:SinceVersion(1.3,FunctionType3)]'");
                    }
                    return;
                }
            
            default:
                ctx.Fail<APM_GraphicsStateParameter_BG>("BG is required to one of 'fn:SinceVersion(1.3,dictionary);stream', was " + utval.Type);
                return;
        }
    }


}

/// <summary>
/// GraphicsStateParameter_BG2 
/// </summary>
internal partial class APM_GraphicsStateParameter_BG2 : APM_GraphicsStateParameter_BG2__Base
{
}


internal partial class APM_GraphicsStateParameter_BG2__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "GraphicsStateParameter_BG2";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.3m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var (utval, wasIR) = ctx.GetOptional<APM_GraphicsStateParameter_BG2>(obj, "BG2", IndirectRequirement.Either);
        if (utval == null) { return; }
        switch (utval.Type) 
        {
            case PdfObjectType.DictionaryObj:
                {
                    var val =  (PdfDictionary)utval;
                    // no indirect obj reqs
                    // no special cases
                    // no value restrictions
                    if (APM_FunctionType2.MatchesType(ctx, val)) 
                    {
                        ctx.Run<APM_FunctionType2, PdfDictionary>(stack, val, obj);
                    } else if (APM_FunctionType3.MatchesType(ctx, val)) 
                    {
                        ctx.Run<APM_FunctionType3, PdfDictionary>(stack, val, obj);
                    }else 
                    {
                        ctx.Fail<APM_GraphicsStateParameter_BG2>("BG2 did not match any allowable types: '[FunctionType2,FunctionType3]'");
                    }
                    return;
                }
            case PdfObjectType.NameObj:
                {
                    var val =  (PdfName)utval;
                    // no indirect obj reqs
                    // no special cases
                    // no value restrictions
                    // no linked objects
                    return;
                }
            case PdfObjectType.StreamObj:
                {
                    var val =  (PdfStream)utval;
                    if (!wasIR) { ctx.Fail<APM_GraphicsStateParameter_BG2>("BG2 is required to be indirect when a stream"); return; }
                    // no special cases
                    // no value restrictions
                    if (APM_FunctionType0.MatchesType(ctx, val.Dictionary)) 
                    {
                        ctx.Run<APM_FunctionType0, PdfDictionary>(stack, val.Dictionary, obj);
                    } else if (APM_FunctionType4.MatchesType(ctx, val.Dictionary)) 
                    {
                        ctx.Run<APM_FunctionType4, PdfDictionary>(stack, val.Dictionary, obj);
                    }else 
                    {
                        ctx.Fail<APM_GraphicsStateParameter_BG2>("BG2 did not match any allowable types: '[FunctionType0,FunctionType4]'");
                    }
                    return;
                }
            
            default:
                ctx.Fail<APM_GraphicsStateParameter_BG2>("BG2 is required to one of 'dictionary;name;stream', was " + utval.Type);
                return;
        }
    }


}

/// <summary>
/// GraphicsStateParameter_UCR 
/// </summary>
internal partial class APM_GraphicsStateParameter_UCR : APM_GraphicsStateParameter_UCR__Base
{
}


internal partial class APM_GraphicsStateParameter_UCR__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "GraphicsStateParameter_UCR";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.2m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var (utval, wasIR) = ctx.GetOptional<APM_GraphicsStateParameter_UCR>(obj, "UCR", IndirectRequirement.Either);
        if (utval == null) { return; }
        switch (utval.Type) 
        {
            case PdfObjectType.StreamObj:
                {
                    var val =  (PdfStream)utval;
                    if (!wasIR) { ctx.Fail<APM_GraphicsStateParameter_UCR>("UCR is required to be indirect when a stream"); return; }
                    // no special cases
                    // no value restrictions
                    if (APM_FunctionType0.MatchesType(ctx, val.Dictionary)) 
                    {
                        ctx.Run<APM_FunctionType0, PdfDictionary>(stack, val.Dictionary, obj);
                    } else if ((ctx.Version >= 1.3m && APM_FunctionType4.MatchesType(ctx, val.Dictionary))) 
                    {
                        ctx.Run<APM_FunctionType4, PdfDictionary>(stack, val.Dictionary, obj);
                    }else 
                    {
                        ctx.Fail<APM_GraphicsStateParameter_UCR>("UCR did not match any allowable types: '[FunctionType0,fn:SinceVersion(1.3,FunctionType4)]'");
                    }
                    return;
                }
            case PdfObjectType.DictionaryObj:
                {
                    if (!(ctx.Version >= 1.3m)) 
                    {
                        ctx.Fail<APM_GraphicsStateParameter_UCR>("UCR was type dictionary but not allowed for current conditions: 'fn:SinceVersion(1.3,dictionary)'");
                    }
                    var val =  (PdfDictionary)utval;
                    // no indirect obj reqs
                    // no special cases
                    // no value restrictions
                    if ((ctx.Version >= 1.3m && APM_FunctionType2.MatchesType(ctx, val))) 
                    {
                        ctx.Run<APM_FunctionType2, PdfDictionary>(stack, val, obj);
                    } else if ((ctx.Version >= 1.3m && APM_FunctionType3.MatchesType(ctx, val))) 
                    {
                        ctx.Run<APM_FunctionType3, PdfDictionary>(stack, val, obj);
                    }else 
                    {
                        ctx.Fail<APM_GraphicsStateParameter_UCR>("UCR did not match any allowable types: '[fn:SinceVersion(1.3,FunctionType2),fn:SinceVersion(1.3,FunctionType3)]'");
                    }
                    return;
                }
            
            default:
                ctx.Fail<APM_GraphicsStateParameter_UCR>("UCR is required to one of 'fn:SinceVersion(1.3,dictionary);stream', was " + utval.Type);
                return;
        }
    }


}

/// <summary>
/// GraphicsStateParameter_UCR2 
/// </summary>
internal partial class APM_GraphicsStateParameter_UCR2 : APM_GraphicsStateParameter_UCR2__Base
{
}


internal partial class APM_GraphicsStateParameter_UCR2__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "GraphicsStateParameter_UCR2";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.3m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var (utval, wasIR) = ctx.GetOptional<APM_GraphicsStateParameter_UCR2>(obj, "UCR2", IndirectRequirement.Either);
        if (utval == null) { return; }
        switch (utval.Type) 
        {
            case PdfObjectType.DictionaryObj:
                {
                    var val =  (PdfDictionary)utval;
                    // no indirect obj reqs
                    // no special cases
                    // no value restrictions
                    if (APM_FunctionType2.MatchesType(ctx, val)) 
                    {
                        ctx.Run<APM_FunctionType2, PdfDictionary>(stack, val, obj);
                    } else if (APM_FunctionType3.MatchesType(ctx, val)) 
                    {
                        ctx.Run<APM_FunctionType3, PdfDictionary>(stack, val, obj);
                    }else 
                    {
                        ctx.Fail<APM_GraphicsStateParameter_UCR2>("UCR2 did not match any allowable types: '[FunctionType2,FunctionType3]'");
                    }
                    return;
                }
            case PdfObjectType.NameObj:
                {
                    var val =  (PdfName)utval;
                    // no indirect obj reqs
                    // no special cases
                    // no value restrictions
                    // no linked objects
                    return;
                }
            case PdfObjectType.StreamObj:
                {
                    var val =  (PdfStream)utval;
                    if (!wasIR) { ctx.Fail<APM_GraphicsStateParameter_UCR2>("UCR2 is required to be indirect when a stream"); return; }
                    // no special cases
                    // no value restrictions
                    if (APM_FunctionType0.MatchesType(ctx, val.Dictionary)) 
                    {
                        ctx.Run<APM_FunctionType0, PdfDictionary>(stack, val.Dictionary, obj);
                    } else if (APM_FunctionType4.MatchesType(ctx, val.Dictionary)) 
                    {
                        ctx.Run<APM_FunctionType4, PdfDictionary>(stack, val.Dictionary, obj);
                    }else 
                    {
                        ctx.Fail<APM_GraphicsStateParameter_UCR2>("UCR2 did not match any allowable types: '[FunctionType0,FunctionType4]'");
                    }
                    return;
                }
            
            default:
                ctx.Fail<APM_GraphicsStateParameter_UCR2>("UCR2 is required to one of 'dictionary;name;stream', was " + utval.Type);
                return;
        }
    }


}

/// <summary>
/// GraphicsStateParameter_TR 
/// </summary>
internal partial class APM_GraphicsStateParameter_TR : APM_GraphicsStateParameter_TR__Base
{
}


internal partial class APM_GraphicsStateParameter_TR__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "GraphicsStateParameter_TR";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.2m && version < 2.0m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var (utval, wasIR) = ctx.GetOptional<APM_GraphicsStateParameter_TR>(obj, "TR", IndirectRequirement.Either);
        if (utval == null) { return; }
        switch (utval.Type) 
        {
            case PdfObjectType.ArrayObj:
                {
                    var val =  (PdfArray)utval;
                    // no indirect obj reqs
                    // no special cases
                    // no value restrictions
                    ctx.Run<APM_ArrayOf4Functions, PdfArray>(stack, val, obj);
                    return;
                }
            case PdfObjectType.NameObj:
                {
                    var val =  (PdfName)utval;
                    // no indirect obj reqs
                    // no special cases
                    // no value restrictions
                    // no linked objects
                    return;
                }
            case PdfObjectType.StreamObj:
                {
                    var val =  (PdfStream)utval;
                    if (!wasIR) { ctx.Fail<APM_GraphicsStateParameter_TR>("TR is required to be indirect when a stream"); return; }
                    // no special cases
                    // no value restrictions
                    if (APM_FunctionType0.MatchesType(ctx, val.Dictionary)) 
                    {
                        ctx.Run<APM_FunctionType0, PdfDictionary>(stack, val.Dictionary, obj);
                    } else if ((ctx.Version >= 1.3m && APM_FunctionType4.MatchesType(ctx, val.Dictionary))) 
                    {
                        ctx.Run<APM_FunctionType4, PdfDictionary>(stack, val.Dictionary, obj);
                    }else 
                    {
                        ctx.Fail<APM_GraphicsStateParameter_TR>("TR did not match any allowable types: '[FunctionType0,fn:SinceVersion(1.3,FunctionType4)]'");
                    }
                    return;
                }
            case PdfObjectType.DictionaryObj:
                {
                    if (!(ctx.Version >= 1.3m)) 
                    {
                        ctx.Fail<APM_GraphicsStateParameter_TR>("TR was type dictionary but not allowed for current conditions: 'fn:SinceVersion(1.3,dictionary)'");
                    }
                    var val =  (PdfDictionary)utval;
                    // no indirect obj reqs
                    // no special cases
                    // no value restrictions
                    if ((ctx.Version >= 1.3m && APM_FunctionType2.MatchesType(ctx, val))) 
                    {
                        ctx.Run<APM_FunctionType2, PdfDictionary>(stack, val, obj);
                    } else if ((ctx.Version >= 1.3m && APM_FunctionType3.MatchesType(ctx, val))) 
                    {
                        ctx.Run<APM_FunctionType3, PdfDictionary>(stack, val, obj);
                    }else 
                    {
                        ctx.Fail<APM_GraphicsStateParameter_TR>("TR did not match any allowable types: '[fn:SinceVersion(1.3,FunctionType2),fn:SinceVersion(1.3,FunctionType3)]'");
                    }
                    return;
                }
            
            default:
                ctx.Fail<APM_GraphicsStateParameter_TR>("TR is required to one of 'array;fn:SinceVersion(1.3,dictionary);name;stream', was " + utval.Type);
                return;
        }
    }


}

/// <summary>
/// GraphicsStateParameter_TR2 
/// </summary>
internal partial class APM_GraphicsStateParameter_TR2 : APM_GraphicsStateParameter_TR2__Base
{
}


internal partial class APM_GraphicsStateParameter_TR2__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "GraphicsStateParameter_TR2";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.3m && version < 2.0m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var (utval, wasIR) = ctx.GetOptional<APM_GraphicsStateParameter_TR2>(obj, "TR2", IndirectRequirement.Either);
        if (utval == null) { return; }
        switch (utval.Type) 
        {
            case PdfObjectType.ArrayObj:
                {
                    var val =  (PdfArray)utval;
                    // no indirect obj reqs
                    // no special cases
                    // no value restrictions
                    ctx.Run<APM_ArrayOf4Functions, PdfArray>(stack, val, obj);
                    return;
                }
            case PdfObjectType.DictionaryObj:
                {
                    var val =  (PdfDictionary)utval;
                    // no indirect obj reqs
                    // no special cases
                    // no value restrictions
                    if (APM_FunctionType2.MatchesType(ctx, val)) 
                    {
                        ctx.Run<APM_FunctionType2, PdfDictionary>(stack, val, obj);
                    } else if (APM_FunctionType3.MatchesType(ctx, val)) 
                    {
                        ctx.Run<APM_FunctionType3, PdfDictionary>(stack, val, obj);
                    }else 
                    {
                        ctx.Fail<APM_GraphicsStateParameter_TR2>("TR2 did not match any allowable types: '[FunctionType2,FunctionType3]'");
                    }
                    return;
                }
            case PdfObjectType.NameObj:
                {
                    var val =  (PdfName)utval;
                    // no indirect obj reqs
                    // no special cases
                    // no value restrictions
                    // no linked objects
                    return;
                }
            case PdfObjectType.StreamObj:
                {
                    var val =  (PdfStream)utval;
                    if (!wasIR) { ctx.Fail<APM_GraphicsStateParameter_TR2>("TR2 is required to be indirect when a stream"); return; }
                    // no special cases
                    // no value restrictions
                    if (APM_FunctionType0.MatchesType(ctx, val.Dictionary)) 
                    {
                        ctx.Run<APM_FunctionType0, PdfDictionary>(stack, val.Dictionary, obj);
                    } else if (APM_FunctionType4.MatchesType(ctx, val.Dictionary)) 
                    {
                        ctx.Run<APM_FunctionType4, PdfDictionary>(stack, val.Dictionary, obj);
                    }else 
                    {
                        ctx.Fail<APM_GraphicsStateParameter_TR2>("TR2 did not match any allowable types: '[FunctionType0,FunctionType4]'");
                    }
                    return;
                }
            
            default:
                ctx.Fail<APM_GraphicsStateParameter_TR2>("TR2 is required to one of 'array;dictionary;name;stream', was " + utval.Type);
                return;
        }
    }


}

/// <summary>
/// GraphicsStateParameter_HT 
/// </summary>
internal partial class APM_GraphicsStateParameter_HT : APM_GraphicsStateParameter_HT__Base
{
}


internal partial class APM_GraphicsStateParameter_HT__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "GraphicsStateParameter_HT";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.2m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var (utval, wasIR) = ctx.GetOptional<APM_GraphicsStateParameter_HT>(obj, "HT", IndirectRequirement.Either);
        if (utval == null) { return; }
        switch (utval.Type) 
        {
            case PdfObjectType.DictionaryObj:
                {
                    var val =  (PdfDictionary)utval;
                    // no indirect obj reqs
                    // no special cases
                    // no value restrictions
                    if (APM_HalftoneType1.MatchesType(ctx, val)) 
                    {
                        ctx.Run<APM_HalftoneType1, PdfDictionary>(stack, val, obj);
                    } else if (APM_HalftoneType5.MatchesType(ctx, val)) 
                    {
                        ctx.Run<APM_HalftoneType5, PdfDictionary>(stack, val, obj);
                    }else 
                    {
                        ctx.Fail<APM_GraphicsStateParameter_HT>("HT did not match any allowable types: '[HalftoneType1,HalftoneType5]'");
                    }
                    return;
                }
            case PdfObjectType.NameObj:
                {
                    var val =  (PdfName)utval;
                    // no indirect obj reqs
                    // no special cases
                    // no value restrictions
                    // no linked objects
                    return;
                }
            case PdfObjectType.StreamObj:
                {
                    var val =  (PdfStream)utval;
                    if (!wasIR) { ctx.Fail<APM_GraphicsStateParameter_HT>("HT is required to be indirect when a stream"); return; }
                    // no special cases
                    // no value restrictions
                    if (APM_HalftoneType6.MatchesType(ctx, val.Dictionary)) 
                    {
                        ctx.Run<APM_HalftoneType6, PdfDictionary>(stack, val.Dictionary, obj);
                    } else if (APM_HalftoneType10.MatchesType(ctx, val.Dictionary)) 
                    {
                        ctx.Run<APM_HalftoneType10, PdfDictionary>(stack, val.Dictionary, obj);
                    } else if ((ctx.Version >= 1.3m && APM_HalftoneType16.MatchesType(ctx, val.Dictionary))) 
                    {
                        ctx.Run<APM_HalftoneType16, PdfDictionary>(stack, val.Dictionary, obj);
                    }else 
                    {
                        ctx.Fail<APM_GraphicsStateParameter_HT>("HT did not match any allowable types: '[HalftoneType6,HalftoneType10,fn:SinceVersion(1.3,HalftoneType16)]'");
                    }
                    return;
                }
            
            default:
                ctx.Fail<APM_GraphicsStateParameter_HT>("HT is required to one of 'dictionary;name;stream', was " + utval.Type);
                return;
        }
    }


}

/// <summary>
/// GraphicsStateParameter_FL 
/// </summary>
internal partial class APM_GraphicsStateParameter_FL : APM_GraphicsStateParameter_FL__Base
{
}


internal partial class APM_GraphicsStateParameter_FL__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "GraphicsStateParameter_FL";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.3m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfNumber, APM_GraphicsStateParameter_FL>(obj, "FL", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        
        var FL = obj.Get("FL");
        if (!(gt(FL,0))) 
        {
            ctx.Fail<APM_GraphicsStateParameter_FL>($"Invalid value {val}, allowed are: [fn:Eval(@FL>0)]");
        }
        // no linked objects
        
    }


}

/// <summary>
/// GraphicsStateParameter_SM 
/// </summary>
internal partial class APM_GraphicsStateParameter_SM : APM_GraphicsStateParameter_SM__Base
{
}


internal partial class APM_GraphicsStateParameter_SM__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "GraphicsStateParameter_SM";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.3m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfNumber, APM_GraphicsStateParameter_SM>(obj, "SM", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        
        var SM = obj.Get("SM");
        if (!((gte(SM,0)&&lte(SM,1)))) 
        {
            ctx.Fail<APM_GraphicsStateParameter_SM>($"Invalid value {val}, allowed are: [fn:Eval((@SM>=0) && (@SM<=1))]");
        }
        // no linked objects
        
    }


}

/// <summary>
/// GraphicsStateParameter_SA 
/// </summary>
internal partial class APM_GraphicsStateParameter_SA : APM_GraphicsStateParameter_SA__Base
{
}


internal partial class APM_GraphicsStateParameter_SA__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "GraphicsStateParameter_SA";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.2m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfBoolean, APM_GraphicsStateParameter_SA>(obj, "SA", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// GraphicsStateParameter_BM Table 134 and Table 135
/// </summary>
internal partial class APM_GraphicsStateParameter_BM : APM_GraphicsStateParameter_BM__Base
{
}


internal partial class APM_GraphicsStateParameter_BM__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "GraphicsStateParameter_BM";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.4m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var (utval, wasIR) = ctx.GetOptional<APM_GraphicsStateParameter_BM>(obj, "BM", IndirectRequirement.Either);
        if (utval == null) { return; }
        switch (utval.Type) 
        {
            case PdfObjectType.NameObj:
                {
                    var val =  (PdfName)utval;
                    // no indirect obj reqs
                    // no special cases
                    
                    
                    if (!((ctx.Version < 1.4m && val == "Compatible") || val == "Normal" || val == "Multiply" || val == "Screen" || val == "Difference" || val == "Darken" || val == "Lighten" || val == "ColorDodge" || val == "ColorBurn" || val == "Exclusion" || val == "HardLight" || val == "Overlay" || val == "SoftLight" || val == "Luminosity" || val == "Hue" || val == "Saturation" || val == "Color")) 
                    {
                        ctx.Fail<APM_GraphicsStateParameter_BM>($"Invalid value {val}, allowed are: [fn:Deprecated(1.4,Compatible),Normal,Multiply,Screen,Difference,Darken,Lighten,ColorDodge,ColorBurn,Exclusion,HardLight,Overlay,SoftLight,Luminosity,Hue,Saturation,Color]");
                    }
                    // no linked objects
                    return;
                }
            case PdfObjectType.ArrayObj:
                {
                    if (!((ctx.Version < 2.0m))) 
                    {
                        ctx.Fail<APM_GraphicsStateParameter_BM>("BM was type array but not allowed for current conditions: 'fn:Deprecated(2.0,array)'");
                    }
                    var val =  (PdfArray)utval;
                    // no indirect obj reqs
                    // no special cases
                    // no value restrictions
                    ctx.Run<APM_ArrayOfBlendModes, PdfArray>(stack, val, obj);
                    return;
                }
            
            default:
                ctx.Fail<APM_GraphicsStateParameter_BM>("BM is required to one of 'fn:Deprecated(2.0,array);name', was " + utval.Type);
                return;
        }
    }


}

/// <summary>
/// GraphicsStateParameter_SMask 
/// </summary>
internal partial class APM_GraphicsStateParameter_SMask : APM_GraphicsStateParameter_SMask__Base
{
}


internal partial class APM_GraphicsStateParameter_SMask__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "GraphicsStateParameter_SMask";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.4m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var (utval, wasIR) = ctx.GetOptional<APM_GraphicsStateParameter_SMask>(obj, "SMask", IndirectRequirement.Either);
        if (utval == null) { return; }
        switch (utval.Type) 
        {
            case PdfObjectType.DictionaryObj:
                {
                    var val =  (PdfDictionary)utval;
                    // no indirect obj reqs
                    // no special cases
                    // no value restrictions
                    if (APM_SoftMaskAlpha.MatchesType(ctx, val)) 
                    {
                        ctx.Run<APM_SoftMaskAlpha, PdfDictionary>(stack, val, obj);
                    } else if (APM_SoftMaskLuminosity.MatchesType(ctx, val)) 
                    {
                        ctx.Run<APM_SoftMaskLuminosity, PdfDictionary>(stack, val, obj);
                    }else 
                    {
                        ctx.Fail<APM_GraphicsStateParameter_SMask>("SMask did not match any allowable types: '[SoftMaskAlpha,SoftMaskLuminosity]'");
                    }
                    return;
                }
            case PdfObjectType.NameObj:
                {
                    var val =  (PdfName)utval;
                    // no indirect obj reqs
                    // no special cases
                    
                    
                    if (!(val == "None")) 
                    {
                        ctx.Fail<APM_GraphicsStateParameter_SMask>($"Invalid value {val}, allowed are: [None]");
                    }
                    // no linked objects
                    return;
                }
            
            default:
                ctx.Fail<APM_GraphicsStateParameter_SMask>("SMask is required to one of 'dictionary;name', was " + utval.Type);
                return;
        }
    }


}

/// <summary>
/// GraphicsStateParameter_CA 
/// </summary>
internal partial class APM_GraphicsStateParameter_CA : APM_GraphicsStateParameter_CA__Base
{
}


internal partial class APM_GraphicsStateParameter_CA__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "GraphicsStateParameter_CA";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.4m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfNumber, APM_GraphicsStateParameter_CA>(obj, "CA", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        
        var CA = obj.Get("CA");
        if (!((gte(CA,0)&&lte(CA,1)))) 
        {
            ctx.Fail<APM_GraphicsStateParameter_CA>($"Invalid value {val}, allowed are: [fn:Eval((@CA>=0) && (@CA<=1))]");
        }
        // no linked objects
        
    }


}

/// <summary>
/// GraphicsStateParameter_ca 
/// </summary>
internal partial class APM_GraphicsStateParameter_ca : APM_GraphicsStateParameter_ca__Base
{
}


internal partial class APM_GraphicsStateParameter_ca__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "GraphicsStateParameter_ca";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.4m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfNumber, APM_GraphicsStateParameter_ca>(obj, "ca", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        
        var ca = obj.Get("ca");
        if (!((gte(ca,0)&&lte(ca,1)))) 
        {
            ctx.Fail<APM_GraphicsStateParameter_ca>($"Invalid value {val}, allowed are: [fn:Eval((@ca>=0) && (@ca<=1))]");
        }
        // no linked objects
        
    }


}

/// <summary>
/// GraphicsStateParameter_AIS 
/// </summary>
internal partial class APM_GraphicsStateParameter_AIS : APM_GraphicsStateParameter_AIS__Base
{
}


internal partial class APM_GraphicsStateParameter_AIS__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "GraphicsStateParameter_AIS";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.4m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfBoolean, APM_GraphicsStateParameter_AIS>(obj, "AIS", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// GraphicsStateParameter_TK 
/// </summary>
internal partial class APM_GraphicsStateParameter_TK : APM_GraphicsStateParameter_TK__Base
{
}


internal partial class APM_GraphicsStateParameter_TK__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "GraphicsStateParameter_TK";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.4m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfBoolean, APM_GraphicsStateParameter_TK>(obj, "TK", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// GraphicsStateParameter_UseBlackPtComp 
/// </summary>
internal partial class APM_GraphicsStateParameter_UseBlackPtComp : APM_GraphicsStateParameter_UseBlackPtComp__Base
{
}


internal partial class APM_GraphicsStateParameter_UseBlackPtComp__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "GraphicsStateParameter_UseBlackPtComp";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 2.0m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfName, APM_GraphicsStateParameter_UseBlackPtComp>(obj, "UseBlackPtComp", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        
        
        if (!(val == "OFF" || val == "ON" || val == "Default")) 
        {
            ctx.Fail<APM_GraphicsStateParameter_UseBlackPtComp>($"Invalid value {val}, allowed are: [OFF,ON,Default]");
        }
        // no linked objects
        
    }


}

/// <summary>
/// GraphicsStateParameter_HTO 
/// </summary>
internal partial class APM_GraphicsStateParameter_HTO : APM_GraphicsStateParameter_HTO__Base
{
}


internal partial class APM_GraphicsStateParameter_HTO__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "GraphicsStateParameter_HTO";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 2.0m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfArray, APM_GraphicsStateParameter_HTO>(obj, "HTO", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        ctx.Run<APM_ArrayOf_2Numbers, PdfArray>(stack, val, obj);
        
    }


}

/// <summary>
/// GraphicsStateParameter_HTP 
/// </summary>
internal partial class APM_GraphicsStateParameter_HTP : APM_GraphicsStateParameter_HTP__Base
{
}


internal partial class APM_GraphicsStateParameter_HTP__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "GraphicsStateParameter_HTP";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.2m && version < 1.3m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfArray, APM_GraphicsStateParameter_HTP>(obj, "HTP", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        ctx.Run<APM_ArrayOf_2Integers, PdfArray>(stack, val, obj);
        
    }


}

