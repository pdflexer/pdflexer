// AUTOGENERATED DO NOT MODIFY

using PdfLexer;
using static PdfLexer.Validation.MathUtil;

namespace PdfLexer.Validation;

using System.Linq;

internal partial class APM_StructureAttributesDict : APM_StructureAttributesDict__Base
{
}

internal partial class APM_StructureAttributesDict__Base : ISpecification<PdfDictionary>
{
    public static bool RuleGroup() { return true; }
    public static string Name { get; } = "StructureAttributesDict";
    public static bool AppliesTo(decimal version, List<string> extensions) => true; // managed by links
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        ctx.Run<APM_StructureAttributesDict_O, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_NS, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_Placement, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_WritingMode, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_BackgroundColor, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_BorderColor, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_BorderStyle, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_BorderThickness, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_Padding, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_Color, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_SpaceBefore, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_SpaceAfter, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_StartIndent, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_EndIndent, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_TextIndent, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_TextAlign, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_BBox, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_Width, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_Height, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_BlockAlign, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_InlineAlign, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_TBorderStyle, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_TPadding, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_BaselineShift, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_LineHeight, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_TextPosition, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_TextDecorationColor, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_TextDecorationThickness, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_TextDecorationType, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_RubyAlign, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_RubyPosition, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_GlyphOrientationVertical, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_ColumnCount, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_ColumnGap, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_ColumnWidths, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_ListNumbering, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_ContinuedList, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_ContinuedForm, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_Role, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_Checked, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_checked, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_Desc, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_RowSpan, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_ColSpan, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_Headers, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_Scope, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_Summary, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_Short, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_P, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_Type, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_Subtype, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_StructureAttributesDict_Contents, PdfDictionary>(stack, obj, parent);
        switch (ctx.Version) {
            case 1.3m:
                foreach (var extra in obj.Keys.Where(x=> !AllowedFields_13.Contains(x)))
                {
                    ctx.Fail<APM_StructureAttributesDict>($"Unknown field {extra} for version 1.3");
                }
                break;
            case 1.4m:
                foreach (var extra in obj.Keys.Where(x=> !AllowedFields_14.Contains(x)))
                {
                    ctx.Fail<APM_StructureAttributesDict>($"Unknown field {extra} for version 1.4");
                }
                break;
            case 1.5m:
                foreach (var extra in obj.Keys.Where(x=> !AllowedFields_15.Contains(x)))
                {
                    ctx.Fail<APM_StructureAttributesDict>($"Unknown field {extra} for version 1.5");
                }
                break;
            case 1.6m:
                foreach (var extra in obj.Keys.Where(x=> !AllowedFields_16.Contains(x)))
                {
                    ctx.Fail<APM_StructureAttributesDict>($"Unknown field {extra} for version 1.6");
                }
                break;
            case 1.7m:
                foreach (var extra in obj.Keys.Where(x=> !AllowedFields_17.Contains(x)))
                {
                    ctx.Fail<APM_StructureAttributesDict>($"Unknown field {extra} for version 1.7");
                }
                break;
            case 1.8m:
                foreach (var extra in obj.Keys.Where(x=> !AllowedFields_18.Contains(x)))
                {
                    ctx.Fail<APM_StructureAttributesDict>($"Unknown field {extra} for version 1.8");
                }
                break;
            case 1.9m:
                foreach (var extra in obj.Keys.Where(x=> !AllowedFields_19.Contains(x)))
                {
                    ctx.Fail<APM_StructureAttributesDict>($"Unknown field {extra} for version 1.9");
                }
                break;
            case 2.0m:
                foreach (var extra in obj.Keys.Where(x=> !AllowedFields_20.Contains(x)))
                {
                    ctx.Fail<APM_StructureAttributesDict>($"Unknown field {extra} for version 2.0");
                }
                break;
            default:
                break;
        }
    }

    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) 
    {
        var c = ctx.Clone();
        c.Run<APM_StructureAttributesDict_Type, PdfDictionary>(new CallStack(), obj, null);
        if (c.Errors.Any())
        {
            return false;
        }
        return true;
    }

    public static List<string> AllowedFields_13 { get; } = new List<string> 
    {
        "O"
    };
    public static HashSet<string> AllowedFields_14 { get; } = new HashSet<string> 
    {
        "O", "Placement", "WritingMode", "SpaceBefore", "SpaceAfter", "StartIndent", "EndIndent", "TextIndent", "TextAlign", "BBox", "Width", "Height", "BlockAlign", "InlineAlign", "BaselineShift", "LineHeight", "TextDecorationType", "ListNumbering", "Role", "RowSpan", "ColSpan", "Headers", "Scope", "Type"
    };
    public static HashSet<string> AllowedFields_15 { get; } = new HashSet<string> 
    {
        "O", "Placement", "WritingMode", "BackgroundColor", "BorderColor", "BorderStyle", "BorderThickness", "Padding", "Color", "SpaceBefore", "SpaceAfter", "StartIndent", "EndIndent", "TextIndent", "TextAlign", "BBox", "Width", "Height", "BlockAlign", "InlineAlign", "TBorderStyle", "TPadding", "BaselineShift", "LineHeight", "TextDecorationColor", "TextDecorationThickness", "TextDecorationType", "RubyAlign", "RubyPosition", "GlyphOrientationVertical", "ListNumbering", "Role", "RowSpan", "ColSpan", "Headers", "Scope", "Type"
    };
    public static HashSet<string> AllowedFields_16 { get; } = new HashSet<string> 
    {
        "O", "Placement", "WritingMode", "BackgroundColor", "BorderColor", "BorderStyle", "BorderThickness", "Padding", "Color", "SpaceBefore", "SpaceAfter", "StartIndent", "EndIndent", "TextIndent", "TextAlign", "BBox", "Width", "Height", "BlockAlign", "InlineAlign", "TBorderStyle", "TPadding", "BaselineShift", "LineHeight", "TextDecorationColor", "TextDecorationThickness", "TextDecorationType", "RubyAlign", "RubyPosition", "GlyphOrientationVertical", "ColumnCount", "ColumnGap", "ColumnWidths", "ListNumbering", "Role", "RowSpan", "ColSpan", "Headers", "Scope", "P", "Type"
    };
    public static HashSet<string> AllowedFields_17 { get; } = new HashSet<string> 
    {
        "O", "Placement", "WritingMode", "BackgroundColor", "BorderColor", "BorderStyle", "BorderThickness", "Padding", "Color", "SpaceBefore", "SpaceAfter", "StartIndent", "EndIndent", "TextIndent", "TextAlign", "BBox", "Width", "Height", "BlockAlign", "InlineAlign", "TBorderStyle", "TPadding", "BaselineShift", "LineHeight", "TextDecorationColor", "TextDecorationThickness", "TextDecorationType", "RubyAlign", "RubyPosition", "GlyphOrientationVertical", "ColumnCount", "ColumnGap", "ColumnWidths", "ListNumbering", "Role", "Checked", "checked", "Desc", "RowSpan", "ColSpan", "Headers", "Scope", "Summary", "P", "Type", "Subtype"
    };
    public static HashSet<string> AllowedFields_18 { get; } = new HashSet<string> 
    {
        "O", "Placement", "WritingMode", "BackgroundColor", "BorderColor", "BorderStyle", "BorderThickness", "Padding", "Color", "SpaceBefore", "SpaceAfter", "StartIndent", "EndIndent", "TextIndent", "TextAlign", "BBox", "Width", "Height", "BlockAlign", "InlineAlign", "TBorderStyle", "TPadding", "BaselineShift", "LineHeight", "TextDecorationColor", "TextDecorationThickness", "TextDecorationType", "RubyAlign", "RubyPosition", "GlyphOrientationVertical", "ColumnCount", "ColumnGap", "ColumnWidths", "ListNumbering", "Role", "Checked", "checked", "Desc", "RowSpan", "ColSpan", "Headers", "Scope", "Summary", "P", "Type", "Subtype"
    };
    public static HashSet<string> AllowedFields_19 { get; } = new HashSet<string> 
    {
        "O", "Placement", "WritingMode", "BackgroundColor", "BorderColor", "BorderStyle", "BorderThickness", "Padding", "Color", "SpaceBefore", "SpaceAfter", "StartIndent", "EndIndent", "TextIndent", "TextAlign", "BBox", "Width", "Height", "BlockAlign", "InlineAlign", "TBorderStyle", "TPadding", "BaselineShift", "LineHeight", "TextDecorationColor", "TextDecorationThickness", "TextDecorationType", "RubyAlign", "RubyPosition", "GlyphOrientationVertical", "ColumnCount", "ColumnGap", "ColumnWidths", "ListNumbering", "Role", "Checked", "checked", "Desc", "RowSpan", "ColSpan", "Headers", "Scope", "Summary", "P", "Type", "Subtype"
    };
    public static HashSet<string> AllowedFields_20 { get; } = new HashSet<string> 
    {
        "O", "NS", "Placement", "WritingMode", "BackgroundColor", "BorderColor", "BorderStyle", "BorderThickness", "Padding", "Color", "SpaceBefore", "SpaceAfter", "StartIndent", "EndIndent", "TextIndent", "TextAlign", "BBox", "Width", "Height", "BlockAlign", "InlineAlign", "TBorderStyle", "TPadding", "BaselineShift", "LineHeight", "TextPosition", "TextDecorationColor", "TextDecorationThickness", "TextDecorationType", "RubyAlign", "RubyPosition", "GlyphOrientationVertical", "ColumnCount", "ColumnGap", "ColumnWidths", "ListNumbering", "ContinuedList", "ContinuedForm", "Role", "Checked", "Desc", "RowSpan", "ColSpan", "Headers", "Scope", "Summary", "Short", "P", "Type", "Subtype"
    };
    


}

/// <summary>
/// StructureAttributesDict_O Table 360 and Table 376
/// </summary>
internal partial class APM_StructureAttributesDict_O : APM_StructureAttributesDict_O__Base
{
}


internal partial class APM_StructureAttributesDict_O__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_O";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.3m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetRequired<PdfName, APM_StructureAttributesDict_O>(obj, "O", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restictions
        // no linked objects
        
    }


}

/// <summary>
/// StructureAttributesDict_NS Table 360
/// </summary>
internal partial class APM_StructureAttributesDict_NS : APM_StructureAttributesDict_NS__Base
{
}


internal partial class APM_StructureAttributesDict_NS__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_NS";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 2.0m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var O = obj.Get("O");
        var val = ctx.GetOptional<PdfDictionary, APM_StructureAttributesDict_NS>(obj, "NS", IndirectRequirement.MustBeIndirect);
        if ((eq(O,"NSO")) && val == null) {
            ctx.Fail<APM_StructureAttributesDict_NS>("NS is required when 'fn:IsRequired(@O==NSO)"); return;
        } else if (val == null) {
            return;
        }
        // no special cases
        // no value restrictions
        ctx.Run<APM_Namespace, PdfDictionary>(stack, val, obj);
        
    }


}

/// <summary>
/// StructureAttributesDict_Placement Table 378
/// </summary>
internal partial class APM_StructureAttributesDict_Placement : APM_StructureAttributesDict_Placement__Base
{
}


internal partial class APM_StructureAttributesDict_Placement__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_Placement";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.4m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfName, APM_StructureAttributesDict_Placement>(obj, "Placement", IndirectRequirement.Either);
        if (val == null) { return; }
        var O = obj.Get("O");
        if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_Placement>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
        }
        
        
        if (!(val == "Block" || val == "Before" || val == "Start" || val == "End" || ctx.Version < 2.0m && val == "Inline")) 
        {
            ctx.Fail<APM_StructureAttributesDict_Placement>($"Invalid value {val}, allowed are: [Block,Before,Start,End,fn:BeforeVersion(2.0,Inline)]");
        }
        // no linked objects
        
    }


}

/// <summary>
/// StructureAttributesDict_WritingMode Table 378
/// </summary>
internal partial class APM_StructureAttributesDict_WritingMode : APM_StructureAttributesDict_WritingMode__Base
{
}


internal partial class APM_StructureAttributesDict_WritingMode__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_WritingMode";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.4m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfName, APM_StructureAttributesDict_WritingMode>(obj, "WritingMode", IndirectRequirement.Either);
        if (val == null) { return; }
        var O = obj.Get("O");
        if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_WritingMode>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
        }
        
        
        if (!(val == "LrTb" || val == "RlTb" || val == "TbRl" || (ctx.Version < 2.0m || (ctx.Version >= 2.0m && val == "TbLr")) || (ctx.Version < 2.0m || (ctx.Version >= 2.0m && val == "LrBt")) || (ctx.Version < 2.0m || (ctx.Version >= 2.0m && val == "RlBt")) || (ctx.Version < 2.0m || (ctx.Version >= 2.0m && val == "BtRl")) || (ctx.Version < 2.0m || (ctx.Version >= 2.0m && val == "BtLr")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_WritingMode>($"Invalid value {val}, allowed are: [LrTb,RlTb,TbRl,fn:SinceVersion(2.0,TbLr),fn:SinceVersion(2.0,LrBt),fn:SinceVersion(2.0,RlBt),fn:SinceVersion(2.0,BtRl),fn:SinceVersion(2.0,BtLr)]");
        }
        // no linked objects
        
    }


}

/// <summary>
/// StructureAttributesDict_BackgroundColor Table 378
/// </summary>
internal partial class APM_StructureAttributesDict_BackgroundColor : APM_StructureAttributesDict_BackgroundColor__Base
{
}


internal partial class APM_StructureAttributesDict_BackgroundColor__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_BackgroundColor";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.5m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfArray, APM_StructureAttributesDict_BackgroundColor>(obj, "BackgroundColor", IndirectRequirement.Either);
        if (val == null) { return; }
        var O = obj.Get("O");
        if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_BackgroundColor>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
        }
        // no value restrictions
        ctx.Run<APM_ArrayOf_3RGBNumbers, PdfArray>(stack, val, obj);
        
    }


}

/// <summary>
/// StructureAttributesDict_BorderColor Table 378
/// </summary>
internal partial class APM_StructureAttributesDict_BorderColor : APM_StructureAttributesDict_BorderColor__Base
{
}


internal partial class APM_StructureAttributesDict_BorderColor__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_BorderColor";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.5m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfArray, APM_StructureAttributesDict_BorderColor>(obj, "BorderColor", IndirectRequirement.Either);
        if (val == null) { return; }
        var O = obj.Get("O");
        if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_BorderColor>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
        }
        // no value restrictions
        if (APM_ArrayOf_4BorderColorArrays.MatchesType(ctx, val)) 
        {
            ctx.Run<APM_ArrayOf_4BorderColorArrays, PdfArray>(stack, val, obj);
        } else if (APM_ArrayOf_3RGBNumbers.MatchesType(ctx, val)) 
        {
            ctx.Run<APM_ArrayOf_3RGBNumbers, PdfArray>(stack, val, obj);
        }else 
        {
            ctx.Fail<APM_StructureAttributesDict_BorderColor>("BorderColor did not match any allowable types: '[ArrayOf_4BorderColorArrays,ArrayOf_3RGBNumbers]'");
        }
        
    }


}

/// <summary>
/// StructureAttributesDict_BorderStyle Table 378
/// </summary>
internal partial class APM_StructureAttributesDict_BorderStyle : APM_StructureAttributesDict_BorderStyle__Base
{
}


internal partial class APM_StructureAttributesDict_BorderStyle__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_BorderStyle";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.5m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var (utval, wasIR) = ctx.GetOptional<APM_StructureAttributesDict_BorderStyle>(obj, "BorderStyle", IndirectRequirement.Either);
        if (utval == null) { return; }
        switch (utval.Type) 
        {
            case PdfObjectType.ArrayObj:
                {
                    var val =  (PdfArray)utval;
                    // no indirect obj reqs
                    var O = obj.Get("O");
                    if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
                    {
                        ctx.Fail<APM_StructureAttributesDict_BorderStyle>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
                    }
                    // no value restrictions
                    ctx.Run<APM_ArrayOf_4BorderStyleNames, PdfArray>(stack, val, obj);
                    return;
                }
            case PdfObjectType.NameObj:
                {
                    var val =  (PdfName)utval;
                    // no indirect obj reqs
                    var O = obj.Get("O");
                    if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
                    {
                        ctx.Fail<APM_StructureAttributesDict_BorderStyle>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
                    }
                    
                    
                    if (!(val == "None" || val == "Hidden" || val == "Dotted" || val == "Dashed" || val == "Solid" || val == "Double" || val == "Groove" || val == "Ridge" || val == "Inset" || val == "Outset")) 
                    {
                        ctx.Fail<APM_StructureAttributesDict_BorderStyle>($"Invalid value {val}, allowed are: [None,Hidden,Dotted,Dashed,Solid,Double,Groove,Ridge,Inset,Outset]");
                    }
                    // no linked objects
                    return;
                }
            
            default:
                ctx.Fail<APM_StructureAttributesDict_BorderStyle>("BorderStyle is required to one of 'array;name', was " + utval.Type);
                return;
        }
    }


}

/// <summary>
/// StructureAttributesDict_BorderThickness Table 378
/// </summary>
internal partial class APM_StructureAttributesDict_BorderThickness : APM_StructureAttributesDict_BorderThickness__Base
{
}


internal partial class APM_StructureAttributesDict_BorderThickness__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_BorderThickness";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.5m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var (utval, wasIR) = ctx.GetOptional<APM_StructureAttributesDict_BorderThickness>(obj, "BorderThickness", IndirectRequirement.Either);
        if (utval == null) { return; }
        switch (utval.Type) 
        {
            case PdfObjectType.ArrayObj:
                {
                    var val =  (PdfArray)utval;
                    // no indirect obj reqs
                    var O = obj.Get("O");
                    if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
                    {
                        ctx.Fail<APM_StructureAttributesDict_BorderThickness>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
                    }
                    // no value restrictions
                    ctx.Run<APM_ArrayOf_4BorderThicknessNumbers, PdfArray>(stack, val, obj);
                    return;
                }
            case PdfObjectType.NumericObj:
                {
                    var val =  (PdfNumber)utval;
                    // no indirect obj reqs
                    var O = obj.Get("O");
                    if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
                    {
                        ctx.Fail<APM_StructureAttributesDict_BorderThickness>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
                    }
                    // no value restrictions
                    // no linked objects
                    return;
                }
            
            default:
                ctx.Fail<APM_StructureAttributesDict_BorderThickness>("BorderThickness is required to one of 'array;number', was " + utval.Type);
                return;
        }
    }


}

/// <summary>
/// StructureAttributesDict_Padding Table 378
/// </summary>
internal partial class APM_StructureAttributesDict_Padding : APM_StructureAttributesDict_Padding__Base
{
}


internal partial class APM_StructureAttributesDict_Padding__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_Padding";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.5m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var (utval, wasIR) = ctx.GetOptional<APM_StructureAttributesDict_Padding>(obj, "Padding", IndirectRequirement.Either);
        if (utval == null) { return; }
        switch (utval.Type) 
        {
            case PdfObjectType.ArrayObj:
                {
                    var val =  (PdfArray)utval;
                    // no indirect obj reqs
                    var O = obj.Get("O");
                    if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
                    {
                        ctx.Fail<APM_StructureAttributesDict_Padding>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
                    }
                    // no value restrictions
                    ctx.Run<APM_ArrayOf_4Integers, PdfArray>(stack, val, obj);
                    return;
                }
            case PdfObjectType.NumericObj:
                {
                    var val =  (PdfNumber)utval;
                    // no indirect obj reqs
                    var O = obj.Get("O");
                    if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
                    {
                        ctx.Fail<APM_StructureAttributesDict_Padding>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
                    }
                    // no value restrictions
                    // no linked objects
                    return;
                }
            
            default:
                ctx.Fail<APM_StructureAttributesDict_Padding>("Padding is required to one of 'array;number', was " + utval.Type);
                return;
        }
    }


}

/// <summary>
/// StructureAttributesDict_Color Table 378
/// </summary>
internal partial class APM_StructureAttributesDict_Color : APM_StructureAttributesDict_Color__Base
{
}


internal partial class APM_StructureAttributesDict_Color__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_Color";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.5m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfArray, APM_StructureAttributesDict_Color>(obj, "Color", IndirectRequirement.Either);
        if (val == null) { return; }
        var O = obj.Get("O");
        if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_Color>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
        }
        // no value restrictions
        ctx.Run<APM_ArrayOf_3RGBNumbers, PdfArray>(stack, val, obj);
        
    }


}

/// <summary>
/// StructureAttributesDict_SpaceBefore Table 379
/// </summary>
internal partial class APM_StructureAttributesDict_SpaceBefore : APM_StructureAttributesDict_SpaceBefore__Base
{
}


internal partial class APM_StructureAttributesDict_SpaceBefore__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_SpaceBefore";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.4m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfNumber, APM_StructureAttributesDict_SpaceBefore>(obj, "SpaceBefore", IndirectRequirement.Either);
        if (val == null) { return; }
        var O = obj.Get("O");
        if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_SpaceBefore>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
        }
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// StructureAttributesDict_SpaceAfter Table 379
/// </summary>
internal partial class APM_StructureAttributesDict_SpaceAfter : APM_StructureAttributesDict_SpaceAfter__Base
{
}


internal partial class APM_StructureAttributesDict_SpaceAfter__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_SpaceAfter";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.4m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfNumber, APM_StructureAttributesDict_SpaceAfter>(obj, "SpaceAfter", IndirectRequirement.Either);
        if (val == null) { return; }
        var O = obj.Get("O");
        if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_SpaceAfter>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
        }
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// StructureAttributesDict_StartIndent Table 379
/// </summary>
internal partial class APM_StructureAttributesDict_StartIndent : APM_StructureAttributesDict_StartIndent__Base
{
}


internal partial class APM_StructureAttributesDict_StartIndent__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_StartIndent";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.4m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfNumber, APM_StructureAttributesDict_StartIndent>(obj, "StartIndent", IndirectRequirement.Either);
        if (val == null) { return; }
        var O = obj.Get("O");
        if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_StartIndent>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
        }
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// StructureAttributesDict_EndIndent Table 379
/// </summary>
internal partial class APM_StructureAttributesDict_EndIndent : APM_StructureAttributesDict_EndIndent__Base
{
}


internal partial class APM_StructureAttributesDict_EndIndent__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_EndIndent";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.4m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfNumber, APM_StructureAttributesDict_EndIndent>(obj, "EndIndent", IndirectRequirement.Either);
        if (val == null) { return; }
        var O = obj.Get("O");
        if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_EndIndent>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
        }
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// StructureAttributesDict_TextIndent Table 379
/// </summary>
internal partial class APM_StructureAttributesDict_TextIndent : APM_StructureAttributesDict_TextIndent__Base
{
}


internal partial class APM_StructureAttributesDict_TextIndent__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_TextIndent";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.4m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfNumber, APM_StructureAttributesDict_TextIndent>(obj, "TextIndent", IndirectRequirement.Either);
        if (val == null) { return; }
        var O = obj.Get("O");
        if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_TextIndent>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
        }
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// StructureAttributesDict_TextAlign Table 379
/// </summary>
internal partial class APM_StructureAttributesDict_TextAlign : APM_StructureAttributesDict_TextAlign__Base
{
}


internal partial class APM_StructureAttributesDict_TextAlign__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_TextAlign";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.4m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfName, APM_StructureAttributesDict_TextAlign>(obj, "TextAlign", IndirectRequirement.Either);
        if (val == null) { return; }
        var O = obj.Get("O");
        if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_TextAlign>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
        }
        
        
        if (!(val == "Start" || val == "Center" || val == "End" || val == "Justify")) 
        {
            ctx.Fail<APM_StructureAttributesDict_TextAlign>($"Invalid value {val}, allowed are: [Start,Center,End,Justify]");
        }
        // no linked objects
        
    }


}

/// <summary>
/// StructureAttributesDict_BBox Table 379 and Table 385 - https://github.com/pdf-association/pdf-issues/issues/226
/// </summary>
internal partial class APM_StructureAttributesDict_BBox : APM_StructureAttributesDict_BBox__Base
{
}


internal partial class APM_StructureAttributesDict_BBox__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_BBox";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.4m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfArray, APM_StructureAttributesDict_BBox>(obj, "BBox", IndirectRequirement.Either);
        if (val == null) { return; }
        var O = obj.Get("O");
        if (!(((eq(O,"Layout")||eq(O,"Artifact"))||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_BBox>($"Value failed special case check: fn:Eval(((@O==Layout) || (@O==Artifact)) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
        }
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// StructureAttributesDict_Width Table 379
/// </summary>
internal partial class APM_StructureAttributesDict_Width : APM_StructureAttributesDict_Width__Base
{
}


internal partial class APM_StructureAttributesDict_Width__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_Width";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.4m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var (utval, wasIR) = ctx.GetOptional<APM_StructureAttributesDict_Width>(obj, "Width", IndirectRequirement.Either);
        if (utval == null) { return; }
        switch (utval.Type) 
        {
            case PdfObjectType.NameObj:
                {
                    var val =  (PdfName)utval;
                    // no indirect obj reqs
                    var O = obj.Get("O");
                    if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
                    {
                        ctx.Fail<APM_StructureAttributesDict_Width>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
                    }
                    // no value restrictions
                    // no linked objects
                    return;
                }
            case PdfObjectType.NumericObj:
                {
                    var val =  (PdfNumber)utval;
                    // no indirect obj reqs
                    var O = obj.Get("O");
                    if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
                    {
                        ctx.Fail<APM_StructureAttributesDict_Width>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
                    }
                    // no value restrictions
                    // no linked objects
                    return;
                }
            
            default:
                ctx.Fail<APM_StructureAttributesDict_Width>("Width is required to one of 'name;number', was " + utval.Type);
                return;
        }
    }


}

/// <summary>
/// StructureAttributesDict_Height Table 379
/// </summary>
internal partial class APM_StructureAttributesDict_Height : APM_StructureAttributesDict_Height__Base
{
}


internal partial class APM_StructureAttributesDict_Height__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_Height";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.4m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var (utval, wasIR) = ctx.GetOptional<APM_StructureAttributesDict_Height>(obj, "Height", IndirectRequirement.Either);
        if (utval == null) { return; }
        switch (utval.Type) 
        {
            case PdfObjectType.NameObj:
                {
                    var val =  (PdfName)utval;
                    // no indirect obj reqs
                    var O = obj.Get("O");
                    if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
                    {
                        ctx.Fail<APM_StructureAttributesDict_Height>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
                    }
                    // no value restrictions
                    // no linked objects
                    return;
                }
            case PdfObjectType.NumericObj:
                {
                    var val =  (PdfNumber)utval;
                    // no indirect obj reqs
                    var O = obj.Get("O");
                    if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
                    {
                        ctx.Fail<APM_StructureAttributesDict_Height>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
                    }
                    // no value restrictions
                    // no linked objects
                    return;
                }
            
            default:
                ctx.Fail<APM_StructureAttributesDict_Height>("Height is required to one of 'name;number', was " + utval.Type);
                return;
        }
    }


}

/// <summary>
/// StructureAttributesDict_BlockAlign Table 379
/// </summary>
internal partial class APM_StructureAttributesDict_BlockAlign : APM_StructureAttributesDict_BlockAlign__Base
{
}


internal partial class APM_StructureAttributesDict_BlockAlign__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_BlockAlign";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.4m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfName, APM_StructureAttributesDict_BlockAlign>(obj, "BlockAlign", IndirectRequirement.Either);
        if (val == null) { return; }
        var O = obj.Get("O");
        if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_BlockAlign>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
        }
        
        
        if (!(val == "Before" || val == "Middle" || val == "After" || val == "Justify")) 
        {
            ctx.Fail<APM_StructureAttributesDict_BlockAlign>($"Invalid value {val}, allowed are: [Before,Middle,After,Justify]");
        }
        // no linked objects
        
    }


}

/// <summary>
/// StructureAttributesDict_InlineAlign Table 379
/// </summary>
internal partial class APM_StructureAttributesDict_InlineAlign : APM_StructureAttributesDict_InlineAlign__Base
{
}


internal partial class APM_StructureAttributesDict_InlineAlign__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_InlineAlign";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.4m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfName, APM_StructureAttributesDict_InlineAlign>(obj, "InlineAlign", IndirectRequirement.Either);
        if (val == null) { return; }
        var O = obj.Get("O");
        if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_InlineAlign>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
        }
        
        
        if (!(val == "Start" || val == "Center" || val == "End")) 
        {
            ctx.Fail<APM_StructureAttributesDict_InlineAlign>($"Invalid value {val}, allowed are: [Start,Center,End]");
        }
        // no linked objects
        
    }


}

/// <summary>
/// StructureAttributesDict_TBorderStyle Table 379
/// </summary>
internal partial class APM_StructureAttributesDict_TBorderStyle : APM_StructureAttributesDict_TBorderStyle__Base
{
}


internal partial class APM_StructureAttributesDict_TBorderStyle__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_TBorderStyle";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.5m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var (utval, wasIR) = ctx.GetOptional<APM_StructureAttributesDict_TBorderStyle>(obj, "TBorderStyle", IndirectRequirement.Either);
        if (utval == null) { return; }
        switch (utval.Type) 
        {
            case PdfObjectType.ArrayObj:
                {
                    var val =  (PdfArray)utval;
                    // no indirect obj reqs
                    var O = obj.Get("O");
                    if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
                    {
                        ctx.Fail<APM_StructureAttributesDict_TBorderStyle>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
                    }
                    // no value restrictions
                    ctx.Run<APM_ArrayOf_4BorderStyleNames, PdfArray>(stack, val, obj);
                    return;
                }
            case PdfObjectType.NameObj:
                {
                    var val =  (PdfName)utval;
                    // no indirect obj reqs
                    var O = obj.Get("O");
                    if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
                    {
                        ctx.Fail<APM_StructureAttributesDict_TBorderStyle>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
                    }
                    
                    
                    if (!(val == "None" || val == "Hidden" || val == "Dotted" || val == "Dashed" || val == "Solid" || val == "Double" || val == "Groove" || val == "Ridge" || val == "Inset" || val == "Outset")) 
                    {
                        ctx.Fail<APM_StructureAttributesDict_TBorderStyle>($"Invalid value {val}, allowed are: [None,Hidden,Dotted,Dashed,Solid,Double,Groove,Ridge,Inset,Outset]");
                    }
                    // no linked objects
                    return;
                }
            
            default:
                ctx.Fail<APM_StructureAttributesDict_TBorderStyle>("TBorderStyle is required to one of 'array;name', was " + utval.Type);
                return;
        }
    }


}

/// <summary>
/// StructureAttributesDict_TPadding Table 379
/// </summary>
internal partial class APM_StructureAttributesDict_TPadding : APM_StructureAttributesDict_TPadding__Base
{
}


internal partial class APM_StructureAttributesDict_TPadding__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_TPadding";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.5m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var (utval, wasIR) = ctx.GetOptional<APM_StructureAttributesDict_TPadding>(obj, "TPadding", IndirectRequirement.Either);
        if (utval == null) { return; }
        switch (utval.Type) 
        {
            case PdfObjectType.ArrayObj:
                {
                    var val =  (PdfArray)utval;
                    // no indirect obj reqs
                    var O = obj.Get("O");
                    if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
                    {
                        ctx.Fail<APM_StructureAttributesDict_TPadding>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
                    }
                    // no value restrictions
                    ctx.Run<APM_ArrayOf_4Integers, PdfArray>(stack, val, obj);
                    return;
                }
            case PdfObjectType.NumericObj:
                {
                    var val =  (PdfIntNumber)utval;
                    // no indirect obj reqs
                    var O = obj.Get("O");
                    if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
                    {
                        ctx.Fail<APM_StructureAttributesDict_TPadding>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
                    }
                    // no value restrictions
                    // no linked objects
                    return;
                }
            
            default:
                ctx.Fail<APM_StructureAttributesDict_TPadding>("TPadding is required to one of 'array;integer', was " + utval.Type);
                return;
        }
    }


}

/// <summary>
/// StructureAttributesDict_BaselineShift Table 380
/// </summary>
internal partial class APM_StructureAttributesDict_BaselineShift : APM_StructureAttributesDict_BaselineShift__Base
{
}


internal partial class APM_StructureAttributesDict_BaselineShift__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_BaselineShift";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.4m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfNumber, APM_StructureAttributesDict_BaselineShift>(obj, "BaselineShift", IndirectRequirement.Either);
        if (val == null) { return; }
        var O = obj.Get("O");
        if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_BaselineShift>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
        }
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// StructureAttributesDict_LineHeight Table 380
/// </summary>
internal partial class APM_StructureAttributesDict_LineHeight : APM_StructureAttributesDict_LineHeight__Base
{
}


internal partial class APM_StructureAttributesDict_LineHeight__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_LineHeight";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.4m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var (utval, wasIR) = ctx.GetOptional<APM_StructureAttributesDict_LineHeight>(obj, "LineHeight", IndirectRequirement.Either);
        if (utval == null) { return; }
        switch (utval.Type) 
        {
            case PdfObjectType.NameObj:
                {
                    var val =  (PdfName)utval;
                    // no indirect obj reqs
                    var O = obj.Get("O");
                    if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
                    {
                        ctx.Fail<APM_StructureAttributesDict_LineHeight>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
                    }
                    
                    
                    if (!(val == "Normal" || val == "Auto")) 
                    {
                        ctx.Fail<APM_StructureAttributesDict_LineHeight>($"Invalid value {val}, allowed are: [Normal,Auto]");
                    }
                    // no linked objects
                    return;
                }
            case PdfObjectType.NumericObj:
                {
                    var val =  (PdfNumber)utval;
                    // no indirect obj reqs
                    var O = obj.Get("O");
                    if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
                    {
                        ctx.Fail<APM_StructureAttributesDict_LineHeight>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
                    }
                    // no value restrictions
                    // no linked objects
                    return;
                }
            
            default:
                ctx.Fail<APM_StructureAttributesDict_LineHeight>("LineHeight is required to one of 'name;number', was " + utval.Type);
                return;
        }
    }


}

/// <summary>
/// StructureAttributesDict_TextPosition Table 380
/// </summary>
internal partial class APM_StructureAttributesDict_TextPosition : APM_StructureAttributesDict_TextPosition__Base
{
}


internal partial class APM_StructureAttributesDict_TextPosition__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_TextPosition";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 2.0m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfName, APM_StructureAttributesDict_TextPosition>(obj, "TextPosition", IndirectRequirement.Either);
        if (val == null) { return; }
        var O = obj.Get("O");
        if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_TextPosition>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
        }
        
        
        if (!(val == "Sup" || val == "Sub" || val == "Normal")) 
        {
            ctx.Fail<APM_StructureAttributesDict_TextPosition>($"Invalid value {val}, allowed are: [Sup,Sub,Normal]");
        }
        // no linked objects
        
    }


}

/// <summary>
/// StructureAttributesDict_TextDecorationColor Table 380
/// </summary>
internal partial class APM_StructureAttributesDict_TextDecorationColor : APM_StructureAttributesDict_TextDecorationColor__Base
{
}


internal partial class APM_StructureAttributesDict_TextDecorationColor__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_TextDecorationColor";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.5m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfArray, APM_StructureAttributesDict_TextDecorationColor>(obj, "TextDecorationColor", IndirectRequirement.Either);
        if (val == null) { return; }
        var O = obj.Get("O");
        if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_TextDecorationColor>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
        }
        // no value restrictions
        ctx.Run<APM_ArrayOf_3RGBNumbers, PdfArray>(stack, val, obj);
        
    }


}

/// <summary>
/// StructureAttributesDict_TextDecorationThickness Table 380
/// </summary>
internal partial class APM_StructureAttributesDict_TextDecorationThickness : APM_StructureAttributesDict_TextDecorationThickness__Base
{
}


internal partial class APM_StructureAttributesDict_TextDecorationThickness__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_TextDecorationThickness";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.5m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfNumber, APM_StructureAttributesDict_TextDecorationThickness>(obj, "TextDecorationThickness", IndirectRequirement.Either);
        if (val == null) { return; }
        var O = obj.Get("O");
        if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_TextDecorationThickness>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
        }
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// StructureAttributesDict_TextDecorationType Table 380
/// </summary>
internal partial class APM_StructureAttributesDict_TextDecorationType : APM_StructureAttributesDict_TextDecorationType__Base
{
}


internal partial class APM_StructureAttributesDict_TextDecorationType__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_TextDecorationType";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.4m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfName, APM_StructureAttributesDict_TextDecorationType>(obj, "TextDecorationType", IndirectRequirement.Either);
        if (val == null) { return; }
        var O = obj.Get("O");
        if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_TextDecorationType>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
        }
        
        
        if (!(val == "None" || val == "Underline" || val == "Overline" || val == "LineThrough")) 
        {
            ctx.Fail<APM_StructureAttributesDict_TextDecorationType>($"Invalid value {val}, allowed are: [None,Underline,Overline,LineThrough]");
        }
        // no linked objects
        
    }


}

/// <summary>
/// StructureAttributesDict_RubyAlign Table 380
/// </summary>
internal partial class APM_StructureAttributesDict_RubyAlign : APM_StructureAttributesDict_RubyAlign__Base
{
}


internal partial class APM_StructureAttributesDict_RubyAlign__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_RubyAlign";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.5m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfName, APM_StructureAttributesDict_RubyAlign>(obj, "RubyAlign", IndirectRequirement.Either);
        if (val == null) { return; }
        var O = obj.Get("O");
        if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_RubyAlign>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
        }
        
        
        if (!(val == "Start" || val == "Center" || val == "End" || val == "Justify" || val == "Distribute")) 
        {
            ctx.Fail<APM_StructureAttributesDict_RubyAlign>($"Invalid value {val}, allowed are: [Start,Center,End,Justify,Distribute]");
        }
        // no linked objects
        
    }


}

/// <summary>
/// StructureAttributesDict_RubyPosition Table 380
/// </summary>
internal partial class APM_StructureAttributesDict_RubyPosition : APM_StructureAttributesDict_RubyPosition__Base
{
}


internal partial class APM_StructureAttributesDict_RubyPosition__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_RubyPosition";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.5m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfName, APM_StructureAttributesDict_RubyPosition>(obj, "RubyPosition", IndirectRequirement.Either);
        if (val == null) { return; }
        var O = obj.Get("O");
        if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_RubyPosition>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
        }
        
        
        if (!(val == "Before" || val == "After" || val == "Warichu" || val == "Inline")) 
        {
            ctx.Fail<APM_StructureAttributesDict_RubyPosition>($"Invalid value {val}, allowed are: [Before,After,Warichu,Inline]");
        }
        // no linked objects
        
    }


}

/// <summary>
/// StructureAttributesDict_GlyphOrientationVertical Table 380 and https://github.com/pdf-association/pdf-issues/issues/152
/// </summary>
internal partial class APM_StructureAttributesDict_GlyphOrientationVertical : APM_StructureAttributesDict_GlyphOrientationVertical__Base
{
}


internal partial class APM_StructureAttributesDict_GlyphOrientationVertical__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_GlyphOrientationVertical";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.5m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var (utval, wasIR) = ctx.GetOptional<APM_StructureAttributesDict_GlyphOrientationVertical>(obj, "GlyphOrientationVertical", IndirectRequirement.Either);
        if (utval == null) { return; }
        switch (utval.Type) 
        {
            case PdfObjectType.NumericObj:
                {
                    var val =  (PdfIntNumber)utval;
                    // no indirect obj reqs
                    var O = obj.Get("O");
                    if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
                    {
                        ctx.Fail<APM_StructureAttributesDict_GlyphOrientationVertical>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
                    }
                    
                    
                    if (!(val == -180 || val == -90 || val == 0 || val == 90 || val == 180 || val == 270 || val == 360)) 
                    {
                        ctx.Fail<APM_StructureAttributesDict_GlyphOrientationVertical>($"Invalid value {val}, allowed are: [-180,-90,0,90,180,270,360]");
                    }
                    // no linked objects
                    return;
                }
            case PdfObjectType.NameObj:
                {
                    var val =  (PdfName)utval;
                    // no indirect obj reqs
                    var O = obj.Get("O");
                    if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
                    {
                        ctx.Fail<APM_StructureAttributesDict_GlyphOrientationVertical>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
                    }
                    
                    
                    if (!(val == "Auto")) 
                    {
                        ctx.Fail<APM_StructureAttributesDict_GlyphOrientationVertical>($"Invalid value {val}, allowed are: [Auto]");
                    }
                    // no linked objects
                    return;
                }
            
            default:
                ctx.Fail<APM_StructureAttributesDict_GlyphOrientationVertical>("GlyphOrientationVertical is required to one of 'integer;name', was " + utval.Type);
                return;
        }
    }


}

/// <summary>
/// StructureAttributesDict_ColumnCount Table 381
/// </summary>
internal partial class APM_StructureAttributesDict_ColumnCount : APM_StructureAttributesDict_ColumnCount__Base
{
}


internal partial class APM_StructureAttributesDict_ColumnCount__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_ColumnCount";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.6m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfIntNumber, APM_StructureAttributesDict_ColumnCount>(obj, "ColumnCount", IndirectRequirement.Either);
        if (val == null) { return; }
        var O = obj.Get("O");
        if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_ColumnCount>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
        }
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// StructureAttributesDict_ColumnGap Table 381
/// </summary>
internal partial class APM_StructureAttributesDict_ColumnGap : APM_StructureAttributesDict_ColumnGap__Base
{
}


internal partial class APM_StructureAttributesDict_ColumnGap__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_ColumnGap";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.6m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var (utval, wasIR) = ctx.GetOptional<APM_StructureAttributesDict_ColumnGap>(obj, "ColumnGap", IndirectRequirement.Either);
        if (utval == null) { return; }
        switch (utval.Type) 
        {
            case PdfObjectType.ArrayObj:
                {
                    var val =  (PdfArray)utval;
                    // no indirect obj reqs
                    var O = obj.Get("O");
                    if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
                    {
                        ctx.Fail<APM_StructureAttributesDict_ColumnGap>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
                    }
                    // no value restrictions
                    ctx.Run<APM_ArrayOfNumbersGeneral, PdfArray>(stack, val, obj);
                    return;
                }
            case PdfObjectType.NumericObj:
                {
                    var val =  (PdfNumber)utval;
                    // no indirect obj reqs
                    var O = obj.Get("O");
                    if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
                    {
                        ctx.Fail<APM_StructureAttributesDict_ColumnGap>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
                    }
                    // no value restrictions
                    // no linked objects
                    return;
                }
            
            default:
                ctx.Fail<APM_StructureAttributesDict_ColumnGap>("ColumnGap is required to one of 'array;number', was " + utval.Type);
                return;
        }
    }


}

/// <summary>
/// StructureAttributesDict_ColumnWidths Table 381
/// </summary>
internal partial class APM_StructureAttributesDict_ColumnWidths : APM_StructureAttributesDict_ColumnWidths__Base
{
}


internal partial class APM_StructureAttributesDict_ColumnWidths__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_ColumnWidths";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.6m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var (utval, wasIR) = ctx.GetOptional<APM_StructureAttributesDict_ColumnWidths>(obj, "ColumnWidths", IndirectRequirement.Either);
        if (utval == null) { return; }
        switch (utval.Type) 
        {
            case PdfObjectType.ArrayObj:
                {
                    var val =  (PdfArray)utval;
                    // no indirect obj reqs
                    var O = obj.Get("O");
                    if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
                    {
                        ctx.Fail<APM_StructureAttributesDict_ColumnWidths>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
                    }
                    // no value restrictions
                    ctx.Run<APM_ArrayOfNumbersGeneral, PdfArray>(stack, val, obj);
                    return;
                }
            case PdfObjectType.NumericObj:
                {
                    var val =  (PdfNumber)utval;
                    // no indirect obj reqs
                    var O = obj.Get("O");
                    if (!((eq(O,"Layout")||!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
                    {
                        ctx.Fail<APM_StructureAttributesDict_ColumnWidths>($"Value failed special case check: fn:Eval((@O==Layout) || ((@O!=List) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
                    }
                    // no value restrictions
                    // no linked objects
                    return;
                }
            
            default:
                ctx.Fail<APM_StructureAttributesDict_ColumnWidths>("ColumnWidths is required to one of 'array;number', was " + utval.Type);
                return;
        }
    }


}

/// <summary>
/// StructureAttributesDict_ListNumbering Table 382
/// </summary>
internal partial class APM_StructureAttributesDict_ListNumbering : APM_StructureAttributesDict_ListNumbering__Base
{
}


internal partial class APM_StructureAttributesDict_ListNumbering__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_ListNumbering";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.4m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfName, APM_StructureAttributesDict_ListNumbering>(obj, "ListNumbering", IndirectRequirement.Either);
        if (val == null) { return; }
        var O = obj.Get("O");
        if (!((eq(O,"List")||!eq(O,"Layout")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_ListNumbering>($"Value failed special case check: fn:Eval((@O==List) || ((@O!=Layout) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
        }
        
        
        if (!(val == "None" || (ctx.Version < 2.0m || (ctx.Version >= 2.0m && val == "Unordered")) || (ctx.Version < 2.0m || (ctx.Version >= 2.0m && val == "Description")) || val == "Disc" || val == "Circle" || val == "Square" || val == "Ordered" || val == "Decimal" || val == "UpperRoman" || val == "LowerRoman" || val == "UpperAlpha" || val == "LowerAlpha")) 
        {
            ctx.Fail<APM_StructureAttributesDict_ListNumbering>($"Invalid value {val}, allowed are: [None,fn:SinceVersion(2.0,Unordered),fn:SinceVersion(2.0,Description),Disc,Circle,Square,Ordered,Decimal,UpperRoman,LowerRoman,UpperAlpha,LowerAlpha]");
        }
        // no linked objects
        
    }


}

/// <summary>
/// StructureAttributesDict_ContinuedList Table 382
/// </summary>
internal partial class APM_StructureAttributesDict_ContinuedList : APM_StructureAttributesDict_ContinuedList__Base
{
}


internal partial class APM_StructureAttributesDict_ContinuedList__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_ContinuedList";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 2.0m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfBoolean, APM_StructureAttributesDict_ContinuedList>(obj, "ContinuedList", IndirectRequirement.Either);
        if (val == null) { return; }
        var O = obj.Get("O");
        if (!((eq(O,"List")||!eq(O,"Layout")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_ContinuedList>($"Value failed special case check: fn:Eval((@O==List) || ((@O!=Layout) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
        }
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// StructureAttributesDict_ContinuedForm Table 382
/// </summary>
internal partial class APM_StructureAttributesDict_ContinuedForm : APM_StructureAttributesDict_ContinuedForm__Base
{
}


internal partial class APM_StructureAttributesDict_ContinuedForm__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_ContinuedForm";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 2.0m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfString, APM_StructureAttributesDict_ContinuedForm>(obj, "ContinuedForm", IndirectRequirement.Either);
        if (val == null) { return; }
        var O = obj.Get("O");
        if (!((eq(O,"List")||!eq(O,"Layout")&&!eq(O,"Table")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_ContinuedForm>($"Value failed special case check: fn:Eval((@O==List) || ((@O!=Layout) && (@O!=Table) && (@O!=PrintField) && (@O!=Table)))");
        }
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// StructureAttributesDict_Role Table 383
/// </summary>
internal partial class APM_StructureAttributesDict_Role : APM_StructureAttributesDict_Role__Base
{
}


internal partial class APM_StructureAttributesDict_Role__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_Role";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.4m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfName, APM_StructureAttributesDict_Role>(obj, "Role", IndirectRequirement.Either);
        if (val == null) { return; }
        var O = obj.Get("O");
        if (!((eq(O,"PrintField")||!eq(O,"Layout")&&!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"Artifact")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_Role>($"Value failed special case check: fn:Eval((@O==PrintField) || ((@O!=Layout) && (@O!=List) && (@O!=Table) && (@O!=Artifact)))");
        }
        
        
        if (!(val == "rb" || val == "cb" || val == "pb" || val == "tv" || val == "lb")) 
        {
            ctx.Fail<APM_StructureAttributesDict_Role>($"Invalid value {val}, allowed are: [rb,cb,pb,tv,lb]");
        }
        // no linked objects
        
    }


}

/// <summary>
/// StructureAttributesDict_Checked Table 383
/// </summary>
internal partial class APM_StructureAttributesDict_Checked : APM_StructureAttributesDict_Checked__Base
{
}


internal partial class APM_StructureAttributesDict_Checked__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_Checked";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.7m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfName, APM_StructureAttributesDict_Checked>(obj, "Checked", IndirectRequirement.Either);
        if (val == null) { return; }
        var O = obj.Get("O");
        if (!((eq(O,"PrintField")||!eq(O,"Layout")&&!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"Artifact")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_Checked>($"Value failed special case check: fn:Eval((@O==PrintField) || ((@O!=Layout) && (@O!=List) && (@O!=Table) && (@O!=Artifact)))");
        }
        
        
        if (!(val == "on" || val == "off" || val == "neutral")) 
        {
            ctx.Fail<APM_StructureAttributesDict_Checked>($"Invalid value {val}, allowed are: [on,off,neutral]");
        }
        // no linked objects
        
    }


}

/// <summary>
/// StructureAttributesDict_checked Table 383
/// </summary>
internal partial class APM_StructureAttributesDict_checked : APM_StructureAttributesDict_checked__Base
{
}


internal partial class APM_StructureAttributesDict_checked__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_checked";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.7m && version < 2.0m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfName, APM_StructureAttributesDict_checked>(obj, "checked", IndirectRequirement.Either);
        if (val == null) { return; }
        var O = obj.Get("O");
        if (!((eq(O,"PrintField")||!eq(O,"Layout")&&!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"Artifact")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_checked>($"Value failed special case check: fn:Eval((@O==PrintField) || ((@O!=Layout) && (@O!=List) && (@O!=Table) && (@O!=Artifact)))");
        }
        
        
        if (!(val == "on" || val == "off" || val == "neutral")) 
        {
            ctx.Fail<APM_StructureAttributesDict_checked>($"Invalid value {val}, allowed are: [on,off,neutral]");
        }
        // no linked objects
        
    }


}

/// <summary>
/// StructureAttributesDict_Desc Table 383
/// </summary>
internal partial class APM_StructureAttributesDict_Desc : APM_StructureAttributesDict_Desc__Base
{
}


internal partial class APM_StructureAttributesDict_Desc__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_Desc";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.7m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfString, APM_StructureAttributesDict_Desc>(obj, "Desc", IndirectRequirement.Either);
        if (val == null) { return; }
        var O = obj.Get("O");
        if (!((eq(O,"PrintField")||!eq(O,"Layout")&&!eq(O,"List")&&!eq(O,"Table")&&!eq(O,"Artifact")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_Desc>($"Value failed special case check: fn:Eval((@O==PrintField) || ((@O!=Layout) && (@O!=List) && (@O!=Table) && (@O!=Artifact)))");
        }
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// StructureAttributesDict_RowSpan Table 384
/// </summary>
internal partial class APM_StructureAttributesDict_RowSpan : APM_StructureAttributesDict_RowSpan__Base
{
}


internal partial class APM_StructureAttributesDict_RowSpan__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_RowSpan";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.4m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfIntNumber, APM_StructureAttributesDict_RowSpan>(obj, "RowSpan", IndirectRequirement.Either);
        if (val == null) { return; }
        var O = obj.Get("O");
        if (!((eq(O,"Table")||!eq(O,"Layout")&&!eq(O,"List")&&!eq(O,"PrintField")&&!eq(O,"Artifact")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_RowSpan>($"Value failed special case check: fn:Eval((@O==Table) || ((@O!=Layout) && (@O!=List) && (@O!=PrintField) && (@O!=Artifact)))");
        }
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// StructureAttributesDict_ColSpan Table 384
/// </summary>
internal partial class APM_StructureAttributesDict_ColSpan : APM_StructureAttributesDict_ColSpan__Base
{
}


internal partial class APM_StructureAttributesDict_ColSpan__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_ColSpan";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.4m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfIntNumber, APM_StructureAttributesDict_ColSpan>(obj, "ColSpan", IndirectRequirement.Either);
        if (val == null) { return; }
        var O = obj.Get("O");
        if (!((eq(O,"Table")||!eq(O,"Layout")&&!eq(O,"List")&&!eq(O,"PrintField")&&!eq(O,"Artifact")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_ColSpan>($"Value failed special case check: fn:Eval((@O==Table) || ((@O!=Layout) && (@O!=List) && (@O!=PrintField) && (@O!=Artifact)))");
        }
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// StructureAttributesDict_Headers Table 384
/// </summary>
internal partial class APM_StructureAttributesDict_Headers : APM_StructureAttributesDict_Headers__Base
{
}


internal partial class APM_StructureAttributesDict_Headers__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_Headers";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.4m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfArray, APM_StructureAttributesDict_Headers>(obj, "Headers", IndirectRequirement.Either);
        if (val == null) { return; }
        var O = obj.Get("O");
        if (!((eq(O,"Table")||!eq(O,"Layout")&&!eq(O,"List")&&!eq(O,"PrintField")&&!eq(O,"Artifact")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_Headers>($"Value failed special case check: fn:Eval((@O==Table) || ((@O!=Layout) && (@O!=List) && (@O!=PrintField) && (@O!=Artifact)))");
        }
        // no value restrictions
        ctx.Run<APM_ArrayOfStringsByte, PdfArray>(stack, val, obj);
        
    }


}

/// <summary>
/// StructureAttributesDict_Scope Table 384
/// </summary>
internal partial class APM_StructureAttributesDict_Scope : APM_StructureAttributesDict_Scope__Base
{
}


internal partial class APM_StructureAttributesDict_Scope__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_Scope";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.4m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfName, APM_StructureAttributesDict_Scope>(obj, "Scope", IndirectRequirement.Either);
        if (val == null) { return; }
        var O = obj.Get("O");
        if (!((eq(O,"Table")||!eq(O,"Layout")&&!eq(O,"List")&&!eq(O,"PrintField")&&!eq(O,"Artifact")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_Scope>($"Value failed special case check: fn:Eval((@O==Table) || ((@O!=Layout) && (@O!=List) && (@O!=PrintField) && (@O!=Artifact)))");
        }
        
        
        if (!(val == "Row" || val == "Column" || val == "Both")) 
        {
            ctx.Fail<APM_StructureAttributesDict_Scope>($"Invalid value {val}, allowed are: [Row,Column,Both]");
        }
        // no linked objects
        
    }


}

/// <summary>
/// StructureAttributesDict_Summary Table 384
/// </summary>
internal partial class APM_StructureAttributesDict_Summary : APM_StructureAttributesDict_Summary__Base
{
}


internal partial class APM_StructureAttributesDict_Summary__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_Summary";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.7m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfString, APM_StructureAttributesDict_Summary>(obj, "Summary", IndirectRequirement.Either);
        if (val == null) { return; }
        var O = obj.Get("O");
        if (!((eq(O,"Table")||!eq(O,"Layout")&&!eq(O,"List")&&!eq(O,"PrintField")&&!eq(O,"Artifact")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_Summary>($"Value failed special case check: fn:Eval((@O==Table) || ((@O!=Layout) && (@O!=List) && (@O!=PrintField) && (@O!=Artifact)))");
        }
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// StructureAttributesDict_Short Table 384
/// </summary>
internal partial class APM_StructureAttributesDict_Short : APM_StructureAttributesDict_Short__Base
{
}


internal partial class APM_StructureAttributesDict_Short__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_Short";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 2.0m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfString, APM_StructureAttributesDict_Short>(obj, "Short", IndirectRequirement.Either);
        if (val == null) { return; }
        var O = obj.Get("O");
        if (!((eq(O,"Table")||!eq(O,"Layout")&&!eq(O,"List")&&!eq(O,"PrintField")&&!eq(O,"Artifact")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_Short>($"Value failed special case check: fn:Eval((@O==Table) || ((@O!=Layout) && (@O!=List) && (@O!=PrintField) && (@O!=Artifact)))");
        }
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// StructureAttributesDict_P Table 361
/// </summary>
internal partial class APM_StructureAttributesDict_P : APM_StructureAttributesDict_P__Base
{
}


internal partial class APM_StructureAttributesDict_P__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_P";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.6m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var O = obj.Get("O");
        var val = ctx.GetOptional<PdfArray, APM_StructureAttributesDict_P>(obj, "P", IndirectRequirement.Either);
        if ((eq(O,"UserProperties")) && val == null) {
            ctx.Fail<APM_StructureAttributesDict_P>("P is required when 'fn:IsRequired(@O==UserProperties)"); return;
        } else if (val == null) {
            return;
        }
        // no special cases
        // no value restrictions
        ctx.Run<APM_ArrayOfUserProperty, PdfArray>(stack, val, obj);
        
    }


}

/// <summary>
/// StructureAttributesDict_Type Table 385
/// </summary>
internal partial class APM_StructureAttributesDict_Type : APM_StructureAttributesDict_Type__Base
{
}


internal partial class APM_StructureAttributesDict_Type__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_Type";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.4m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfName, APM_StructureAttributesDict_Type>(obj, "Type", IndirectRequirement.Either);
        if (val == null) { return; }
        var O = obj.Get("O");
        if (!((eq(O,"Artifact")||!eq(O,"Layout")&&!eq(O,"List")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_Type>($"Value failed special case check: fn:Eval((@O==Artifact) || ((@O!=Layout) && (@O!=List) && (@O!=PrintField) && (@O!=Table)))");
        }
        
        
        if (!(val == "Pagination" || val == "Layout" || val == "Page" || (ctx.Version == 1.7m && (ctx.Extensions.Contains("ADBE_Extn3") && val == "BatesN")) || (ctx.Version < 2.0m || (ctx.Version >= 2.0m && val == "Inline")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_Type>($"Invalid value {val}, allowed are: [Pagination,Layout,Page,fn:IsPDFVersion(1.7,fn:Extension(ADBE_Extn3,BatesN)),fn:SinceVersion(2.0,Inline)]");
        }
        // no linked objects
        
    }


}

/// <summary>
/// StructureAttributesDict_Subtype Table 385
/// </summary>
internal partial class APM_StructureAttributesDict_Subtype : APM_StructureAttributesDict_Subtype__Base
{
}


internal partial class APM_StructureAttributesDict_Subtype__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_Subtype";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.7m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfName, APM_StructureAttributesDict_Subtype>(obj, "Subtype", IndirectRequirement.Either);
        if (val == null) { return; }
        var O = obj.Get("O");
        if (!((eq(O,"Artifact")||!eq(O,"Layout")&&!eq(O,"List")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_Subtype>($"Value failed special case check: fn:Eval((@O==Artifact) || ((@O!=Layout) && (@O!=List) && (@O!=PrintField) && (@O!=Table)))");
        }
        
        
        if (!(val == "Header" || val == "Footer" || val == "Watermark" || (ctx.Version < 2.0m || (ctx.Version >= 2.0m && val == "PageNum")) || (ctx.Version < 2.0m || (ctx.Version >= 2.0m && val == "Bates")) || (ctx.Version < 2.0m || (ctx.Version >= 2.0m && val == "LineNum")) || (ctx.Version < 2.0m || (ctx.Version >= 2.0m && val == "Redaction")))) 
        {
            ctx.Fail<APM_StructureAttributesDict_Subtype>($"Invalid value {val}, allowed are: [Header,Footer,Watermark,fn:SinceVersion(2.0,PageNum),fn:SinceVersion(2.0,Bates),fn:SinceVersion(2.0,LineNum),fn:SinceVersion(2.0,Redaction)]");
        }
        // no linked objects
        
    }


}

/// <summary>
/// StructureAttributesDict_Contents 
/// </summary>
internal partial class APM_StructureAttributesDict_Contents : APM_StructureAttributesDict_Contents__Base
{
}


internal partial class APM_StructureAttributesDict_Contents__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "StructureAttributesDict_Contents";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return false; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var (utval, wasIR) = ctx.GetOptional<APM_StructureAttributesDict_Contents>(obj, "Contents", IndirectRequirement.Either);
        if (utval == null) { return; }
        switch (utval.Type) 
        {
            case PdfObjectType.ArrayObj:
                {
                    var val =  (PdfArray)utval;
                    // no indirect obj reqs
                    var O = obj.Get("O");
                    if (!((eq(O,"Artifact")||!eq(O,"Layout")&&!eq(O,"List")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
                    {
                        ctx.Fail<APM_StructureAttributesDict_Contents>($"Value failed special case check: fn:Eval((@O==Artifact) || ((@O!=Layout) && (@O!=List) && (@O!=PrintField) && (@O!=Table)))");
                    }
                    // no value restrictions
                    ctx.Run<APM_ArrayOfStringsText, PdfArray>(stack, val, obj);
                    return;
                }
            case PdfObjectType.StringObj:
                {
                    var val =  (PdfString)utval;
                    // no indirect obj reqs
                    var O = obj.Get("O");
                    if (!((eq(O,"Artifact")||!eq(O,"Layout")&&!eq(O,"List")&&!eq(O,"PrintField")&&!eq(O,"Table")))) 
                    {
                        ctx.Fail<APM_StructureAttributesDict_Contents>($"Value failed special case check: fn:Eval((@O==Artifact) || ((@O!=Layout) && (@O!=List) && (@O!=PrintField) && (@O!=Table)))");
                    }
                    // no value restrictions
                    // no linked objects
                    return;
                }
            
            default:
                ctx.Fail<APM_StructureAttributesDict_Contents>("Contents is required to one of 'array;string-text', was " + utval.Type);
                return;
        }
    }


}

