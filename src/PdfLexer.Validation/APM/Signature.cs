// AUTOGENERATED DO NOT MODIFY

using PdfLexer;
using static PdfLexer.Validation.MathUtil;

namespace PdfLexer.Validation;

using System.Linq;

internal partial class APM_Signature : APM_Signature__Base
{
}

internal partial class APM_Signature__Base : ISpecification<PdfDictionary>
{
    public static bool RuleGroup() { return true; }
    public static string Name { get; } = "Signature";
    public static bool AppliesTo(decimal version, List<string> extensions) => true; // managed by links
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        ctx.Run<APM_Signature_Type, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_Signature_Filter, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_Signature_SubFilter, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_Signature_Contents, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_Signature_Cert, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_Signature_ByteRange, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_Signature_Reference, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_Signature_Changes, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_Signature_Name, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_Signature_M, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_Signature_Location, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_Signature_Reason, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_Signature_ContactInfo, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_Signature_R, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_Signature_V, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_Signature_Prop_Build, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_Signature_Prop_AuthTime, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_Signature_Prop_AuthType, PdfDictionary>(stack, obj, parent);
        switch (ctx.Version) {
            case 1.3m:
                foreach (var extra in obj.Keys.Where(x=> !AllowedFields_13.Contains(x)))
                {
                    ctx.Fail<APM_Signature>($"Unknown field {extra} for version 1.3");
                }
                break;
            case 1.4m:
                foreach (var extra in obj.Keys.Where(x=> !AllowedFields_14.Contains(x)))
                {
                    ctx.Fail<APM_Signature>($"Unknown field {extra} for version 1.4");
                }
                break;
            case 1.5m:
                foreach (var extra in obj.Keys.Where(x=> !AllowedFields_15.Contains(x)))
                {
                    ctx.Fail<APM_Signature>($"Unknown field {extra} for version 1.5");
                }
                break;
            case 1.6m:
                foreach (var extra in obj.Keys.Where(x=> !AllowedFields_16.Contains(x)))
                {
                    ctx.Fail<APM_Signature>($"Unknown field {extra} for version 1.6");
                }
                break;
            case 1.7m:
                foreach (var extra in obj.Keys.Where(x=> !AllowedFields_17.Contains(x)))
                {
                    ctx.Fail<APM_Signature>($"Unknown field {extra} for version 1.7");
                }
                break;
            case 1.8m:
                foreach (var extra in obj.Keys.Where(x=> !AllowedFields_18.Contains(x)))
                {
                    ctx.Fail<APM_Signature>($"Unknown field {extra} for version 1.8");
                }
                break;
            case 1.9m:
                foreach (var extra in obj.Keys.Where(x=> !AllowedFields_19.Contains(x)))
                {
                    ctx.Fail<APM_Signature>($"Unknown field {extra} for version 1.9");
                }
                break;
            case 2.0m:
                foreach (var extra in obj.Keys.Where(x=> !AllowedFields_20.Contains(x)))
                {
                    ctx.Fail<APM_Signature>($"Unknown field {extra} for version 2.0");
                }
                break;
            default:
                break;
        }
    }

    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) 
    {
        var c = ctx.Clone();
        c.Run<APM_Signature_Type, PdfDictionary>(new CallStack(), obj, null);
        if (c.Errors.Any())
        {
            return false;
        }
        return true;
    }

    public static HashSet<string> AllowedFields_13 { get; } = new HashSet<string> 
    {
        "Type", "Filter", "SubFilter", "Contents", "Cert", "ByteRange", "Changes", "Name", "M", "Location", "Reason", "ContactInfo", "R"
    };
    public static HashSet<string> AllowedFields_14 { get; } = new HashSet<string> 
    {
        "Type", "Filter", "SubFilter", "Contents", "Cert", "ByteRange", "Changes", "Name", "M", "Location", "Reason", "ContactInfo", "R"
    };
    public static HashSet<string> AllowedFields_15 { get; } = new HashSet<string> 
    {
        "Type", "Filter", "SubFilter", "Contents", "Cert", "ByteRange", "Reference", "Changes", "Name", "M", "Location", "Reason", "ContactInfo", "R", "V", "Prop_Build", "Prop_AuthTime", "Prop_AuthType"
    };
    public static HashSet<string> AllowedFields_16 { get; } = new HashSet<string> 
    {
        "Type", "Filter", "SubFilter", "Contents", "Cert", "ByteRange", "Reference", "Changes", "Name", "M", "Location", "Reason", "ContactInfo", "R", "V", "Prop_Build", "Prop_AuthTime", "Prop_AuthType"
    };
    public static HashSet<string> AllowedFields_17 { get; } = new HashSet<string> 
    {
        "Type", "Filter", "SubFilter", "Contents", "Cert", "ByteRange", "Reference", "Changes", "Name", "M", "Location", "Reason", "ContactInfo", "R", "V", "Prop_Build", "Prop_AuthTime", "Prop_AuthType"
    };
    public static HashSet<string> AllowedFields_18 { get; } = new HashSet<string> 
    {
        "Type", "Filter", "SubFilter", "Contents", "Cert", "ByteRange", "Reference", "Changes", "Name", "M", "Location", "Reason", "ContactInfo", "R", "V", "Prop_Build", "Prop_AuthTime", "Prop_AuthType"
    };
    public static HashSet<string> AllowedFields_19 { get; } = new HashSet<string> 
    {
        "Type", "Filter", "SubFilter", "Contents", "Cert", "ByteRange", "Reference", "Changes", "Name", "M", "Location", "Reason", "ContactInfo", "R", "V", "Prop_Build", "Prop_AuthTime", "Prop_AuthType"
    };
    public static HashSet<string> AllowedFields_20 { get; } = new HashSet<string> 
    {
        "Type", "Filter", "SubFilter", "Contents", "Cert", "ByteRange", "Reference", "Changes", "Name", "M", "Location", "Reason", "ContactInfo", "V", "Prop_Build", "Prop_AuthTime", "Prop_AuthType"
    };
    


}

/// <summary>
/// Signature_Type Table 255
/// </summary>
internal partial class APM_Signature_Type : APM_Signature_Type__Base
{
}


internal partial class APM_Signature_Type__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "Signature_Type";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.3m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfName, APM_Signature_Type>(obj, "Type", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        
        
        if (!(val == "Sig")) 
        {
            ctx.Fail<APM_Signature_Type>($"Invalid value {val}, allowed are: [Sig]");
        }
        // no linked objects
        
    }


}

/// <summary>
/// Signature_Filter 
/// </summary>
internal partial class APM_Signature_Filter : APM_Signature_Filter__Base
{
}


internal partial class APM_Signature_Filter__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "Signature_Filter";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.3m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetRequired<PdfName, APM_Signature_Filter>(obj, "Filter", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        
        
        if (!(val == "Adobe.PPKLite" || val == "Entrust.PPKEF" || val == "CICI.SignIt" || val == "VeriSign.PPKVS")) 
        {
            ctx.Fail<APM_Signature_Filter>($"Invalid value {val}, allowed are: [Adobe.PPKLite,Entrust.PPKEF,CICI.SignIt,VeriSign.PPKVS]");
        }
        // no linked objects
        
    }


}

/// <summary>
/// Signature_SubFilter Table 260 and https://github.com/pdf-association/pdf-issues/issues/219
/// </summary>
internal partial class APM_Signature_SubFilter : APM_Signature_SubFilter__Base
{
}


internal partial class APM_Signature_SubFilter__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "Signature_SubFilter";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.3m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfName, APM_Signature_SubFilter>(obj, "SubFilter", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        
        
        if (!((ctx.Version >= 1.3m && val == "adbe.pkcs7.detached") || (ctx.Version <= 2.0m && (ctx.Version >= 1.4m && val == "adbe.pkcs7.sha1")) || (ctx.Version >= 1.3m && val == "adbe.x509.rsa_sha1") || (ctx.Version >= 2.0m && val == "ETSI.CAdES.detached") || (ctx.Version >= 2.0m && val == "ETSI.RFC3161"))) 
        {
            ctx.Fail<APM_Signature_SubFilter>($"Invalid value {val}, allowed are: [fn:SinceVersion(1.3,adbe.pkcs7.detached),fn:Deprecated(2.0,fn:SinceVersion(1.4,adbe.pkcs7.sha1)),fn:SinceVersion(1.3,adbe.x509.rsa_sha1),fn:SinceVersion(2.0,ETSI.CAdES.detached),fn:SinceVersion(2.0,ETSI.RFC3161)]");
        }
        // no linked objects
        
    }


}

/// <summary>
/// Signature_Contents 
/// </summary>
internal partial class APM_Signature_Contents : APM_Signature_Contents__Base
{
}


internal partial class APM_Signature_Contents__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "Signature_Contents";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.3m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetRequired<PdfString, APM_Signature_Contents>(obj, "Contents", IndirectRequirement.Either);
        if (val == null) { return; }
        
        if (!((AlwaysUnencrypted(obj)&&IsHexString(obj)))) 
        {
            ctx.Fail<APM_Signature_Contents>($"Value failed special case check: fn:Eval(fn:AlwaysUnencrypted() && fn:IsHexString())");
        }
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// Signature_Cert Table 260
/// </summary>
internal partial class APM_Signature_Cert : APM_Signature_Cert__Base
{
}


internal partial class APM_Signature_Cert__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "Signature_Cert";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.3m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var (utval, wasIR) = ctx.GetOptional<APM_Signature_Cert>(obj, "Cert", IndirectRequirement.Either);
        
        var SubFilter = obj.Get("SubFilter");
        if ((eq(SubFilter,"adbe.x509.rsa_sha1")) && utval == null) {
            ctx.Fail<APM_Signature_Cert>("Cert is required"); return;
        } else if (utval == null) {
            return;
        }
        
        switch (utval.Type) 
        {
            case PdfObjectType.ArrayObj:
                {
                    var val =  (PdfArray)utval;
                    // no indirect obj reqs
                    // special case is an fn:Ignore, not pertinent to validation
                    // no value restrictions
                    ctx.Run<APM_ArrayOfStringsByte, PdfArray>(stack, val, obj);
                    return;
                }
            case PdfObjectType.StringObj:
                {
                    var val =  (PdfString)utval;
                    // no indirect obj reqs
                    // special case is an fn:Ignore, not pertinent to validation
                    // no value restrictions
                    // no linked objects
                    return;
                }
            
            default:
                ctx.Fail<APM_Signature_Cert>("Cert is required to one of 'array;string-byte', was " + utval.Type);
                return;
        }
    }


}

/// <summary>
/// Signature_ByteRange 
/// </summary>
internal partial class APM_Signature_ByteRange : APM_Signature_ByteRange__Base
{
}


internal partial class APM_Signature_ByteRange__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "Signature_ByteRange";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.3m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfArray, APM_Signature_ByteRange>(obj, "ByteRange", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        ctx.Run<APM_ArrayOfIntegersGeneral, PdfArray>(stack, val, obj);
        
    }


}

/// <summary>
/// Signature_Reference 
/// </summary>
internal partial class APM_Signature_Reference : APM_Signature_Reference__Base
{
}


internal partial class APM_Signature_Reference__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "Signature_Reference";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.5m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfArray, APM_Signature_Reference>(obj, "Reference", IndirectRequirement.Either);
        if (val == null) { return; }
        // special case is an fn:Ignore, not pertinent to validation
        // no value restrictions
        ctx.Run<APM_ArrayOfSignatureReferences, PdfArray>(stack, val, obj);
        
    }


}

/// <summary>
/// Signature_Changes 
/// </summary>
internal partial class APM_Signature_Changes : APM_Signature_Changes__Base
{
}


internal partial class APM_Signature_Changes__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "Signature_Changes";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.3m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfArray, APM_Signature_Changes>(obj, "Changes", IndirectRequirement.Either);
        if (val == null) { return; }
        // special case is an fn:Ignore, not pertinent to validation
        // no value restrictions
        ctx.Run<APM_ArrayOf_3Integers, PdfArray>(stack, val, obj);
        
    }


}

/// <summary>
/// Signature_Name 
/// </summary>
internal partial class APM_Signature_Name : APM_Signature_Name__Base
{
}


internal partial class APM_Signature_Name__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "Signature_Name";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.3m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfString, APM_Signature_Name>(obj, "Name", IndirectRequirement.Either);
        if (val == null) { return; }
        // special case is an fn:Ignore, not pertinent to validation
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// Signature_M 
/// </summary>
internal partial class APM_Signature_M : APM_Signature_M__Base
{
}


internal partial class APM_Signature_M__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "Signature_M";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.3m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfString, APM_Signature_M>(obj, "M", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// Signature_Location 
/// </summary>
internal partial class APM_Signature_Location : APM_Signature_Location__Base
{
}


internal partial class APM_Signature_Location__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "Signature_Location";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.3m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfString, APM_Signature_Location>(obj, "Location", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// Signature_Reason 
/// </summary>
internal partial class APM_Signature_Reason : APM_Signature_Reason__Base
{
}


internal partial class APM_Signature_Reason__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "Signature_Reason";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.3m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfString, APM_Signature_Reason>(obj, "Reason", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// Signature_ContactInfo 
/// </summary>
internal partial class APM_Signature_ContactInfo : APM_Signature_ContactInfo__Base
{
}


internal partial class APM_Signature_ContactInfo__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "Signature_ContactInfo";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.3m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfString, APM_Signature_ContactInfo>(obj, "ContactInfo", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// Signature_R 
/// </summary>
internal partial class APM_Signature_R : APM_Signature_R__Base
{
}


internal partial class APM_Signature_R__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "Signature_R";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.3m && version < 2.0m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfIntNumber, APM_Signature_R>(obj, "R", IndirectRequirement.Either);
        if (val == null) { return; }
        // special case is an fn:Ignore, not pertinent to validation
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// Signature_V 
/// </summary>
internal partial class APM_Signature_V : APM_Signature_V__Base
{
}


internal partial class APM_Signature_V__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "Signature_V";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.5m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfIntNumber, APM_Signature_V>(obj, "V", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// Signature_Prop_Build 
/// </summary>
internal partial class APM_Signature_Prop_Build : APM_Signature_Prop_Build__Base
{
}


internal partial class APM_Signature_Prop_Build__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "Signature_Prop_Build";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.5m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfDictionary, APM_Signature_Prop_Build>(obj, "Prop_Build", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        ctx.Run<APM__UniversalDictionary, PdfDictionary>(stack, val, obj);
        
    }


}

/// <summary>
/// Signature_Prop_AuthTime 
/// </summary>
internal partial class APM_Signature_Prop_AuthTime : APM_Signature_Prop_AuthTime__Base
{
}


internal partial class APM_Signature_Prop_AuthTime__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "Signature_Prop_AuthTime";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.5m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfIntNumber, APM_Signature_Prop_AuthTime>(obj, "Prop_AuthTime", IndirectRequirement.Either);
        if (val == null) { return; }
        // special case is an fn:Ignore, not pertinent to validation
        
        var PropAuthTime = obj.Get("Prop_AuthTime");
        if (!(gte(PropAuthTime,0))) 
        {
            ctx.Fail<APM_Signature_Prop_AuthTime>($"Invalid value {val}, allowed are: [fn:Eval(@Prop_AuthTime>=0)]");
        }
        // no linked objects
        
    }


}

/// <summary>
/// Signature_Prop_AuthType 
/// </summary>
internal partial class APM_Signature_Prop_AuthType : APM_Signature_Prop_AuthType__Base
{
}


internal partial class APM_Signature_Prop_AuthType__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "Signature_Prop_AuthType";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.5m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var val = ctx.GetOptional<PdfName, APM_Signature_Prop_AuthType>(obj, "Prop_AuthType", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        // no linked objects
        
    }


}

