// AUTOGENERATED DO NOT MODIFY

using PdfLexer;
using static PdfLexer.Validation.MathUtil;

namespace PdfLexer.Validation;

using System.Linq;

internal partial class APM_OptContentConfig : APM_OptContentConfig__Base
{
}

internal partial class APM_OptContentConfig__Base : ISpecification<PdfDictionary>
{
    public static bool RuleGroup() { return true; }
    public static string Name { get; } = "OptContentConfig";
    public static bool AppliesTo(decimal version, List<string> extensions) => true; // managed by links
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        ctx.Run<APM_OptContentConfig_Name, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_OptContentConfig_Creator, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_OptContentConfig_BaseState, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_OptContentConfig_ON, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_OptContentConfig_OFF, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_OptContentConfig_Intent, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_OptContentConfig_AS, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_OptContentConfig_Order, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_OptContentConfig_ListMode, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_OptContentConfig_RBGroups, PdfDictionary>(stack, obj, parent);
        ctx.Run<APM_OptContentConfig_Locked, PdfDictionary>(stack, obj, parent);
        switch (ctx.Version) {
            case 1.5m:
                foreach (var extra in obj.Keys.Where(x=> !AllowedFields_15.Contains(x)))
                {
                    ctx.Fail<APM_OptContentConfig>($"Unknown field {extra} for version {ctx.Version}");
                }
                break;
            case 1.6m:
            case 1.7m:
            case 1.8m:
            case 1.9m:
            case 2.0m:
                foreach (var extra in obj.Keys.Where(x=> !AllowedFields_16_17_18_19_20.Contains(x)))
                {
                    ctx.Fail<APM_OptContentConfig>($"Unknown field {extra} for version {ctx.Version}");
                }
                break;
            default:
                break;
        }
    }

    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) 
    {
        return false;
    }

    public static HashSet<string> AllowedFields_15 { get; } = new HashSet<string> 
    {
        "AS", "BaseState", "Creator", "Intent", "ListMode", "Name", "OFF", "ON", "Order", "RBGroups"
    };
    public static HashSet<string> AllowedFields_16_17_18_19_20 { get; } = new HashSet<string> 
    {
        "AS", "BaseState", "Creator", "Intent", "ListMode", "Locked", "Name", "OFF", "ON", "Order", "RBGroups"
    };
    


}

/// <summary>
/// OptContentConfig_Name Table 99
/// </summary>
internal partial class APM_OptContentConfig_Name : APM_OptContentConfig_Name__Base
{
}


internal partial class APM_OptContentConfig_Name__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "OptContentConfig_Name";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.5m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var (val, wasIR) = ctx.GetOptional<PdfString, APM_OptContentConfig_Name>(obj, "Name", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// OptContentConfig_Creator 
/// </summary>
internal partial class APM_OptContentConfig_Creator : APM_OptContentConfig_Creator__Base
{
}


internal partial class APM_OptContentConfig_Creator__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "OptContentConfig_Creator";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.5m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var (val, wasIR) = ctx.GetOptional<PdfString, APM_OptContentConfig_Creator>(obj, "Creator", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        // no linked objects
        
    }


}

/// <summary>
/// OptContentConfig_BaseState 
/// </summary>
internal partial class APM_OptContentConfig_BaseState : APM_OptContentConfig_BaseState__Base
{
}


internal partial class APM_OptContentConfig_BaseState__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "OptContentConfig_BaseState";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.5m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var (val, wasIR) = ctx.GetOptional<PdfName, APM_OptContentConfig_BaseState>(obj, "BaseState", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        
        
        if (!(val == PdfName.ON || val == PdfName.OFF || val == PdfName.Unchanged)) 
        {
            ctx.Fail<APM_OptContentConfig_BaseState>($"Invalid value {val}, allowed are: [ON,OFF,Unchanged]");
        }
        // no linked objects
        
    }


}

/// <summary>
/// OptContentConfig_ON 
/// </summary>
internal partial class APM_OptContentConfig_ON : APM_OptContentConfig_ON__Base
{
}


internal partial class APM_OptContentConfig_ON__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "OptContentConfig_ON";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.5m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var (val, wasIR) = ctx.GetOptional<PdfArray, APM_OptContentConfig_ON>(obj, "ON", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        ctx.Run<APM_ArrayOfOptContentGroups, PdfArray>(stack, val, obj);
        
    }


}

/// <summary>
/// OptContentConfig_OFF 
/// </summary>
internal partial class APM_OptContentConfig_OFF : APM_OptContentConfig_OFF__Base
{
}


internal partial class APM_OptContentConfig_OFF__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "OptContentConfig_OFF";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.5m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var (val, wasIR) = ctx.GetOptional<PdfArray, APM_OptContentConfig_OFF>(obj, "OFF", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        ctx.Run<APM_ArrayOfOptContentGroups, PdfArray>(stack, val, obj);
        
    }


}

/// <summary>
/// OptContentConfig_Intent 
/// </summary>
internal partial class APM_OptContentConfig_Intent : APM_OptContentConfig_Intent__Base
{
}


internal partial class APM_OptContentConfig_Intent__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "OptContentConfig_Intent";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.5m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var (utval, wasIR) = ctx.GetOptional<APM_OptContentConfig_Intent>(obj, "Intent", IndirectRequirement.Either);
        if (utval == null) { return; }
        switch (utval.Type) 
        {
            case PdfObjectType.ArrayObj:
                {
                    var val =  (PdfArray)utval;
                    // no indirect obj reqs
                    // no special cases
                    // no value restrictions
                    ctx.Run<APM_ArrayOfNamesGeneral, PdfArray>(stack, val, obj);
                    return;
                }
            case PdfObjectType.NameObj:
                {
                    var val =  (PdfName)utval;
                    // no indirect obj reqs
                    // no special cases
                    
                    
                    if (!(val == PdfName.All || val == PdfName.Design || val == PdfName.View)) 
                    {
                        ctx.Fail<APM_OptContentConfig_Intent>($"Invalid value {val}, allowed are: [All,Design,View]");
                    }
                    // no linked objects
                    return;
                }
            
            default:
                ctx.Fail<APM_OptContentConfig_Intent>("Intent is required to one of 'array;name', was " + utval.Type);
                return;
        }
    }


}

/// <summary>
/// OptContentConfig_AS 
/// </summary>
internal partial class APM_OptContentConfig_AS : APM_OptContentConfig_AS__Base
{
}


internal partial class APM_OptContentConfig_AS__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "OptContentConfig_AS";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.5m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var (val, wasIR) = ctx.GetOptional<PdfArray, APM_OptContentConfig_AS>(obj, "AS", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        ctx.Run<APM_ArrayOfOCUsage, PdfArray>(stack, val, obj);
        
    }


}

/// <summary>
/// OptContentConfig_Order 
/// </summary>
internal partial class APM_OptContentConfig_Order : APM_OptContentConfig_Order__Base
{
}


internal partial class APM_OptContentConfig_Order__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "OptContentConfig_Order";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.5m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var (val, wasIR) = ctx.GetOptional<PdfArray, APM_OptContentConfig_Order>(obj, "Order", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        ctx.Run<APM_ArrayOfOptContentOrderElements, PdfArray>(stack, val, obj);
        
    }


}

/// <summary>
/// OptContentConfig_ListMode 
/// </summary>
internal partial class APM_OptContentConfig_ListMode : APM_OptContentConfig_ListMode__Base
{
}


internal partial class APM_OptContentConfig_ListMode__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "OptContentConfig_ListMode";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.5m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var (val, wasIR) = ctx.GetOptional<PdfName, APM_OptContentConfig_ListMode>(obj, "ListMode", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        
        
        if (!(val == PdfName.AllPages || val == PdfName.VisiblePages)) 
        {
            ctx.Fail<APM_OptContentConfig_ListMode>($"Invalid value {val}, allowed are: [AllPages,VisiblePages]");
        }
        // no linked objects
        
    }


}

/// <summary>
/// OptContentConfig_RBGroups 
/// </summary>
internal partial class APM_OptContentConfig_RBGroups : APM_OptContentConfig_RBGroups__Base
{
}


internal partial class APM_OptContentConfig_RBGroups__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "OptContentConfig_RBGroups";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.5m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var (val, wasIR) = ctx.GetOptional<PdfArray, APM_OptContentConfig_RBGroups>(obj, "RBGroups", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        ctx.Run<APM_ArrayOfArraysRBGroups, PdfArray>(stack, val, obj);
        
    }


}

/// <summary>
/// OptContentConfig_Locked 
/// </summary>
internal partial class APM_OptContentConfig_Locked : APM_OptContentConfig_Locked__Base
{
}


internal partial class APM_OptContentConfig_Locked__Base : ISpecification<PdfDictionary>
{
    public static string Name { get; } = "OptContentConfig_Locked";
    public static bool RuleGroup() { return false; }
    public static bool MatchesType(PdfValidator ctx, PdfDictionary obj) { return false; } // not used for children
    public static bool AppliesTo(decimal version, List<string> extensions) { return version >= 1.6m; }
    public static void Validate(PdfValidator ctx, CallStack stack, PdfDictionary obj, IPdfObject? parent)
    {
        var (val, wasIR) = ctx.GetOptional<PdfArray, APM_OptContentConfig_Locked>(obj, "Locked", IndirectRequirement.Either);
        if (val == null) { return; }
        // no special cases
        // no value restrictions
        ctx.Run<APM_ArrayOfOptContentGroups, PdfArray>(stack, val, obj);
        
    }


}

